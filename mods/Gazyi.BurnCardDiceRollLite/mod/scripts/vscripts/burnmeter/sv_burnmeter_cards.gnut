untyped
global function SvBurnMeterCards_Init
global function AddCustomBurnReward
global function CreateCustomBurnCard
global function CodeCallback_BoostedWeaponDropped
global function CreateMinimapZoneOnEntity
#if DEV
global function GiveTitanAmpedRider
#endif

const float SONAR_PULSE_DELAY = 6.5
const float SONAR_PULSE_LENGTH = 1.5

const float PILOT_WARNING_RADIUS = 640.0
const float PILOT_WARNING_RADIUS_CLOSE = 240.0 // I guess, that's close to melee distance.
const float PILOT_WARNING_DELAY = 1.0

const asset SHIFTER_APPEAR_FX = $"P_phase_shift_main"

const asset FX_DEPLOYABLE_SHIELD_ARCS = $"shield_pilot_CH_arcs"
const asset FX_DEPLOYABLE_SHIELD_LIGHT = $"shield_pilot_CH_dlight"
const int DEPLOYABLE_SHIELD_HEALTH = 850
const int DEPLOYABLE_AMPED_SHIELD_HEALTH = 1000
const int DEPLOYABLE_SHIELD_RADIUS = 84
const int DEPLOYABLE_SHIELD_HEIGHT = 89
const int DEPLOYABLE_SHIELD_FOV = 150

global enum eAnnouncementStyle
{
    ANNOUNCEMENT_STYLE_BIG
    ANNOUNCEMENT_STYLE_QUICK
    ANNOUNCEMENT_STYLE_PLAYER_LEVEL
    ANNOUNCEMENT_STYLE_WEAPON_LEVEL
    ANNOUNCEMENT_STYLE_TITAN_LEVEL
    ANNOUNCEMENT_STYLE_SWEEP
    ANNOUNCEMENT_STYLE_RESULTS
}

// For test: script foreach(entity player in GetPlayerArray()){BurnMeter_GiveRewardDirect(player,"burnmeter_random_foil")}
// Don't add boosts here, do that in SvBurnMeterCards_Init using appropriate function.
// Both BoostWeight table and AllowedBoosts array should have same amount of boosts. Otherwise, server will stuck in loop!!
table<string, int> BoostWeight = {}
array<string> AllowedBoosts = []

struct 
{
    int weightSum = 0
    int shieldFxArcs
    int shieldFxLight
    table< entity, float > lastRTDTime
} file

void function SvBurnMeterCards_Init()
{
    // Dummy Boost
    RegisterDummyBoost()
    BurnReward_GetByRef( "burnmeter_random_foil" ).rewardAvailableCallback = GiveRandomBoostPlayer
    // Custom callbacks
    AddSpawnCallback( "player", BurnCardOnPlayerFirstSpawn )
    AddDeathCallback( "player", BurnCardDeathCallback )
    AddDamageCallback( "player", BurnCardOnTakeDamage )
    AddCallback_OnPilotBecomesTitan( BurnCardOnPilotBecomesTitan )
    AddCallback_OnTitanBecomesPilot( BurnCardOnTitanBecomesPilot )
    AddCallback_OnPlayerRespawned( BurnCardOnPilotRespawn )
    AddCallback_OnTitanGetsNewTitanLoadout( BurnCardOnNewTitanLoadout )
    AddCallback_OnTitanDoomed( BurnCardOnTitanDoomed )
    AddOnRodeoStartedCallback( BurnCardOnRodeoStart )
    AddOnRodeoEndedCallback( BurnCardOnRodeoEnd )
    SetApplyBatteryCallback( BurnCardOnApplyBattery )
    // Fix for crash in lobby.
    if ( !IsLobby() )
    {
        AddSyncedMeleeServerCallback( GetSyncedMeleeChooser( "human", "human" ), BurnCardOnSyncedMelee )
    }
    // Cut Passives
    level.titanPassives[ ePassives.PAS_NUCLEAR_CORE ] <- true
    // Frontier Defense stuff
    EmpTitans_Init()
    RegisterSignal( "StopEMPField" )
    RegisterSignal( "TitanUnDoomed" )
    // Battery ports
    RegisterSignal( "BatteryActivate" )
    // Spectre leech
    RegisterSignal( "ScriptAnimStop" )
    // Turret auto-use
    RegisterSignal( "DeploySentryTurret" )
    // Amped Wall models
    file.shieldFxArcs = PrecacheParticleSystem( FX_DEPLOYABLE_SHIELD_ARCS )
    file.shieldFxLight = PrecacheParticleSystem( FX_DEPLOYABLE_SHIELD_LIGHT )
    PrecacheModel( $"models/fx/pilot_shield_wall.mdl" )
    PrecacheModel( $"models/fx/pilot_shield_wall_01.mdl" )
    PrecacheModel( $"models/fx/pilot_shield_wall_02.mdl" )
    PrecacheModel( $"models/fx/pilot_shield_wall_03.mdl" )
    // Add vanilla boosts
    if ( GetConVarBool( "sv_bc_add_vanilla_boosts" ) )
    {
        // Add vanilla boosts without checks:
        AddVanillaBurnReward( "burnmeter_amped_weapons", 1 )
        AddVanillaBurnReward( "burnmeter_ap_turret_weapon", 1 )
        AddVanillaBurnReward( "burnmeter_phase_rewind", 1 )
        AddVanillaBurnReward( "burnmeter_holopilot_nova", 1 )
        AddVanillaBurnReward( "burnmeter_hard_cover", 1 )
        AddVanillaBurnReward( "burnmeter_amped_weapons_permanent", 1 )
        // Add vanilla boosts with checks:
        if ( !GetConVarBool( "sv_bc_replace_pilot_weapons" ) ) // We'll give different Smart Pistol as primary if this ConVar is true.
        {
            AddVanillaBurnReward( "burnmeter_smart_pistol", 1 )
        }
        if ( EarnMeterMP_IsTitanEarnGametype() )
        {
            AddVanillaBurnReward( "burnmeter_emergency_battery", 1 )
            AddVanillaBurnReward( "burnmeter_at_turret_weapon", 1 )
            // Frontier Defense
            AddVanillaBurnReward( "burnmeter_instant_battery", 1 )
            // Vanilla Unused
            AddVanillaBurnReward( "burnmeter_nuke_titan", 1 )
        }
        if ( GetCurrentPlaylistVarInt( "riff_minimap_state", 0 ) == 0 )
        {
            AddVanillaBurnReward( "burnmeter_maphack", 1 )
            AddVanillaBurnReward( "burnmeter_radar_jammer", 1 )
        }
        if ( GetCurrentPlaylistVarInt( "featured_mode_all_ticks", 0 ) == 0 )
        {
            AddVanillaBurnReward( "burnmeter_ticks", 1 )
        }
    }
    // Custom boosts goes here:
    // ----------------- TF1 Burn Cards - Stealth ------------------
    if ( GetConVarBool( "sv_bc_replace_tactical_abilities" ) )
    {
        // Active Camo - Done
        AddCustomBurnReward("bc_super_cloak", 1, "#BC_SUPER_CLOAK", "#BC_SUPER_CLOAK_DESC", $"", PlayerUsesActiveCamo)
    }
    // Ghost Squad - Done
    AddCustomBurnReward("bc_cloak_forever", 1, "#BC_CLOAK_FOREVER", "#BC_CLOAK_FOREVER_DESC", $"", PlayerUsesGhostSquad)
    // ----------------- TF1 Burn Cards - Speed ------------------
    if ( GetConVarBool( "sv_bc_replace_tactical_abilities" ) )
    {
        // Smuggled Stimulant - Done
        AddCustomBurnReward("bc_super_stim", 1, "#BC_SUPER_STIM", "#BC_SUPER_STIM_DESC", $"", PlayerUsesSmuggledStimulant)
    }
    // Adrenaline Transfusion - Done
    AddCustomBurnReward("bc_stim_forever", 1, "#BC_STIM_FOREVER", "#BC_STIM_FOREVER_DESC", $"", PlayerUsesAdrenalineTransfusion)
    // Prosthetic Legs - Done
    AddCustomBurnReward("bc_fast_movespeed", 1, "#BC_FAST_MOVESPEED", "#BC_FAST_MOVESPEED_DESC", $"", PlayerUsesProstheticLegs)
    // ----------------- TF1 Burn Cards - Intel ------------------
    // Packet Sniffer - Emit Sonar Pulses from player that shows enemies through walls - Done
    AddCustomBurnReward("bc_auto_sonar", 1, "#BC_AUTO_SONAR", "#BC_AUTO_SONAR_DESC", $"", PlayerUsesPacketSniffer)
    // Satellite Uplink - Update the location of all enemies only on the minimap - Done
    if ( GetCurrentPlaylistVarInt( "riff_minimap_state", 0 ) == 0 )
    {
        AddCustomBurnReward("bc_minimap_scan", 1, "#BC_MINIMAP_SCAN", "#BC_MINIMAP_SCAN_DESC", $"", PlayerUsesSatelliteUplink)
    }
    // Spider Sense - Done
    AddCustomBurnReward("bc_pilot_warning", 1, "#BC_PILOT_WARNING", "#BC_PILOT_WARNING_DESC", $"", PlayerUsesSpiderSense)
    // Riffs are not used in Frontier War.
    if ( ( Riff_AllowNPCs() != eAllowNPCs.None && Riff_AllowNPCs() != eAllowNPCs.PlayerControlledOnly ) || GameRules_GetGameMode() == FORT_WAR )
    {
        // Double Agent - Done
        AddCustomBurnReward("bc_double_agent", 1, "#BC_DOUBLE_AGENT", "#BC_DOUBLE_AGENT_DESC", $"", PlayerUsesDoubleAgent)
        
        if ( Riff_AllowNPCs() != eAllowNPCs.SpectreOnly )
        {
            // Conscription - Done
            AddCustomBurnReward("bc_conscription", 1, "#BC_CONSCRIPTION", "#BC_CONSCRIPTION_DESC", $"", PlayerUsesConscription)
        }
        if ( Riff_AllowNPCs() != eAllowNPCs.GruntOnly )
        {
            // WI-FI Virus - Done
            AddCustomBurnReward("bc_pas_wifi_spectre", 1, "#BC_WIFI_SPECTRE_HACK", "#BC_WIFI_SPECTRE_HACK_DESC", $"", PlayerUsesWiFiVirus)
        }
        // Spectre Camo - server-side variant - Done
        AddCustomBurnReward("bc_play_spectre", 1, "#BC_PLAY_SPECTRE", "#BC_PLAY_SPECTRE_DESC", $"", PlayerUsesSpectreCamo)
    }
    // ----------------- TF1 Burn Cards - Misc ------------------
    // Rematch - Test - Spawning works, enemy message is not tested.
    AddCustomBurnReward("bc_rematch", 1, "#BC_REMATCH", "#BC_REMATCH_DESC", $"", PlayerUsesRematch)
    // ----------------- TF1 Burn Cards - Bonus ------------------
    // Maybe needs some score reworks.
    // Decisive Action - Done
    AddCustomBurnReward("bc_free_build_time_1", 1, "#BC_FREE_BUILD_TIME_1", "#BC_FREE_BUILD_TIME_1_DESC", $"", PlayerUsesDecisiveAction)
    // Pull Rank - Done
    AddCustomBurnReward("bc_free_build_time_2", 1, "#BC_FREE_BUILD_TIME_2", "#BC_FREE_BUILD_TIME_2_DESC", $"", PlayerUsesPullRank)
    // Riffs are not used in Frontier War.
    if ( Riff_AllowNPCs() != eAllowNPCs.None && Riff_AllowNPCs() != eAllowNPCs.PlayerControlledOnly || GameRules_GetGameMode() == FORT_WAR )
    {
        if ( Riff_AllowNPCs() != eAllowNPCs.SpectreOnly )
        {
            // Thin the Ranks - Done
            AddCustomBurnReward("bc_hunt_soldier", 1, "#BC_HUNT_SOLDIER", "#BC_HUNT_SOLDIER_DESC", $"", PlayerUsesThintheRanks)
        }
        if ( Riff_AllowNPCs() != eAllowNPCs.GruntOnly )
        {
            // Urban Renewal - Done
            AddCustomBurnReward("bc_hunt_spectre", 1, "#BC_HUNT_SPECTRE", "#BC_HUNT_SPECTRE_DESC", $"", PlayerUsesUrbanRenewal)
        }
    }
    // Most Wanted List - Done
    AddCustomBurnReward("bc_hunt_pilot", 1, "#BC_HUNT_PILOT", "#BC_HUNT_PILOT_DESC", $"", PlayerUsesMostWantedList)
    // Outsource - Done
    AddCustomBurnReward("bc_fast_build_2", 1, "#BC_FAST_BUILD_2", "#BC_FAST_BUILD_2_DESC", $"", PlayerUsesOutsource)
    // ----------------- TF1 Burn Cards - Weapons ------------------
    if ( GetConVarBool( "sv_bc_replace_pilot_weapons" ) )
    {
        // Amped Smart Pistol - Replaces primary - Done
        AddCustomBurnReward("bc_smart_pistol", 1, "#BC_SMART_PISTOL_M2", "#BC_SMART_PISTOL_M2_DESC", $"", PlayerUsesAmpedSmartPistol)
        // TWIN-B Shotgun - Replaces primary - Done
        AddCustomBurnReward("bc_dblbarrel_shotgun", 1, "#WPN_SHOTGUN_DBLBARREL", "#BC_SHOTGUN_DBLBARREL_DESC", $"", PlayerUsesDblBarrelShotgun)
    }
    // ----------------- TF1 Burn Cards - Titan related ------------------
    if ( EarnMeterMP_IsTitanEarnGametype() )
    {
        // Titan - Turbo Engine - Done
        if ( GetCurrentPlaylistVarInt( "featured_mode_turbo_titans", 0 ) == 0 )
        {
            AddCustomBurnReward("bc_extra_dash", 1, "#BC_EXTRA_DASH", "#BC_EXTRA_DASH_DESC", $"", PlayerUsesTurboEngine)
        }
        // Titan - Super Charger - Done
        AddCustomBurnReward("bc_core_charged", 1, "#BC_CORE_CHARGED", "#BC_CORE_CHARGED_DESC", $"", PlayerUsesSuperCharger)
        // Titan - Massive Payload - Done
        AddCustomBurnReward("bc_nuclear_core", 1, "#BC_NUCLEAR_CORE", "#BC_NUCLEAR_CORE_DESC", $"", PlayerUsesMassivePayload)
        // Titan Salvage - Done
        AddCustomBurnReward("bc_hunt_titan", 1, "#BC_HUNT_TITAN", "#GEAR_AT_HUNTER_KIT_DESC", $"", PlayerUsesTitanSalvage)
        
        if ( GetConVarBool( "sv_bc_replace_titan_weapons" ) )
        {
            // Permanent Amped Titan weapons and abilities - Done, but not all weapons have burn mods.
            AddCustomBurnReward("bc_titan_amped_weapons", 1, "#BC_TITAN_AMPED_WEAPONS", "#BC_TITAN_AMPED_WEAPONS_DESC", $"", PlayerUsesTitanAmpedWeapons)
        }
    }
    // ================= Custom - New in TF|2 =================
    // ----------------- Custom - Pilot Abilities ------------------
    if ( GetConVarBool( "sv_bc_replace_tactical_abilities" ) )
    {
        // Longer lasting Pulse Blade - Done
        AddCustomBurnReward("bc_super_grenade_sonar", 1, "#BC_SUPER_GRENADE_SONAR", "#BC_SUPER_GRENADE_SONAR_DESC", $"", PlayerUsesSuperPulseBlade)
        // Pulse Blade Jammer - Done
        AddCustomBurnReward("bc_grenade_sonar_jammer", 1, "#BC_GRENADE_SONAR_JAMMER", "#BC_GRENADE_SONAR_JAMMER_DESC", $"", PlayerUsesPulseBladeJammer)
        // Holopilot Shift - Done
        AddCustomBurnReward("bc_holopilot_shift", 1, "#BC_HOLOPILOT_SHIFT", "#BC_HOLOPILOT_SHIFT_DESC", $"", PlayerUsesHolopilotShift)
        // Holopilot Mimic - Done
        AddCustomBurnReward("bc_holopilot_mimic", 1, "#BC_HOLOPILOT_MIMIC", "#BC_HOLOPILOT_MIMIC_DESC", $"", PlayerUsesHolopilotMimic)
        // Longer lasting Phase Shift - Done
        AddCustomBurnReward("bc_super_shifter", 1, "#BC_SUPER_SHIFTER", "#BC_SUPER_SHIFTER_DESC", $"", PlayerUsesSuperPhaseShift)
        // Long Range grapple - Done
        AddCustomBurnReward("bc_long_grapple", 1, "#BC_LONG_GRAPPLE", "#BC_LONG_GRAPPLE_DESC", $"", PlayerUsesLongGrapple)
        
        if ( GetCurrentPlaylistVarInt( "featured_mode_all_grapple", 0 ) == 0 )
        {
            // Grapple with 3 charges - Done
            AddCustomBurnReward("bc_super_grapple", 1, "#featured_mode_all_grapple", "#BC_SUPER_GRAPPLE_DESC", $"", PlayerUsesSuperGrapple)
        }
    }
    // Phase Lifesaver - Phase Rewind on critical damage - Done
    AddCustomBurnReward("bc_phase_lifesaver_rewind", 1, "#BC_PHASE_LIFESAVER", "#BC_PHASEREWIND_LIFESAVER_DESC", $"", PlayerUsesPhaseLifesaverRewind)
    // Phase Lifesaver - Phase Shift on critical damage - Done
    AddCustomBurnReward("bc_phase_lifesaver_shift", 1, "#BC_PHASE_LIFESAVER", "#BC_PHASESHIFT_LIFESAVER_DESC", $"", PlayerUsesPhaseLifesaverShift)
    // Personal Shield - Done
    AddCustomBurnReward("bc_particle_shield", 1, "#BC_MOBILE_SHIELD", "#BC_MOBILE_SHIELD_DESC", $"", PlayerUsesPersonalShield)
    // Mobile A-Wall - Done
    AddCustomBurnReward("bc_mobile_amped_wall", 1, "#BC_MOBILE_AMPED_WALL", "#BC_MOBILE_AMPED_WALL_DESC", $"", PlayerUsesMobileAmpedWall)
    // ----------------- Custom - Weapons ------------------
    // Amped Ordinance - Done
    AddCustomBurnReward("bc_amped_grenades", 1, "#PATCH_ORDNANCE", "#TITAN_UPGRADE_AMPED_ORDNANCE", $"", PlayerUsesAmpedGrenades)
    // Arc Trap - Done, requires client-side for displaying restock progress.
    AddCustomBurnReward("bc_arc_trap", 1, "#WPN_ARC_TRAP", "#BC_ARC_TRAP_DESC", $"", PlayerUsesArcTrap)
    // ----------------- Custom - Titan ------------------
    if ( EarnMeterMP_IsTitanEarnGametype() )
    {
        // Shield regeneration - Done
        AddCustomBurnReward("bc_titan_shield_regen", 1, "#GEAR_SHIELD_REACTOR", "#GEAR_SHIELD_REACTOR_DESC", $"", PlayerUsesTitanShieldRegen)
        // Emergency Titan - Normal Titan - Done - Disabled by default
        //AddCustomBurnReward("burnmeter_emergency_titan_normal", 1, "#BURNMETER_EMERGENCY_TITAN", "#BURNMETER_EMERGENCY_TITAN_NORMAL_DESC", $"", PlayerUsesEmergencyTitan)
        // Emergency Titan - 50% health, no core - Done
        AddCustomBurnReward("burnmeter_emergency_titan", 1, "#BURNMETER_EMERGENCY_TITAN", "#BURNMETER_EMERGENCY_TITAN_NOCORE_DESC", $"", PlayerUsesEmergencyTitanNoCore)
        // Amped Rider - Done
        AddCustomBurnReward("bc_titanrider_amped_weapons", 1, "#MP_CHIN_RODEO_EXPRESS", "#BC_TITANRIDER_AMPED_RIDER_DESC", $"", PlayerUsesTitanAmpedRider)
        // Arc Field - Done
        AddCustomBurnReward("bc_titan_arc_field", 1, "#BC_TITAN_ARC_FIELD", "#BC_TITAN_ARC_FIELD_DESC", $"", PlayerUsesTitanArcField)
    }
    // ----------------- Custom - Support NPCs ----------------- 
    // Check for Live fire and Coliseum maps - they don't have spawn points for titanfall drops.
    // TODO: Replace Titan drop point function with custom one?
    if ( Riff_AllowNPCs() != eAllowNPCs.None && GetMapName().find( "mp_lf_" ) == null && GetMapName().find( "coliseum" ) == null )
    {
        if ( Riff_AllowNPCs() != eAllowNPCs.SpectreOnly )
        {
            // Support Squad - Grunts - Done
            AddCustomBurnReward("bc_grunt_droppod", 1, "#BC_DROPPOD", "#BC_GRUNT_DROPPOD_DESC", $"", PlayerUsesGruntDroppod)
        }
        if ( Riff_AllowNPCs() != eAllowNPCs.GruntOnly )
        {
            // Support Squad - Spectres - Done
            AddCustomBurnReward("bc_spectre_droppod", 1, "#BC_DROPPOD", "#BC_SPECTRE_DROPPOD_DESC", $"", PlayerUsesSpectreDroppod)
            // Support Squad - Stalkers - Done
            AddCustomBurnReward("bc_stalker_droppod", 1, "#BC_DROPPOD", "#BC_STALKER_DROPPOD_DESC", $"", PlayerUsesStalkerDroppod)
            // Reaperfall - Done
            AddCustomBurnReward("bc_reaperfall", 1, "#BURNMETER_REAPER", "#BURNMETER_REAPER_DESC", $"", PlayerUsesReaperfall)
        }
        // Cloak Drone - Done
        AddCustomBurnReward("bc_cloak_drone", 1, "#NPC_CLOAK_DRONE", "#BC_CLOAK_DRONE_DESC", $"", PlayerUsesCloakDrone)
    }
    // Custom boosts End
    foreach( boost in AllowedBoosts )
    {
        file.weightSum += BoostWeight[boost]
    }
    #if DEV
    printt( "[BurnCardDiceRoll] Total Weight: ", file.weightSum )
    #endif
}
// Dummy RTD boost for burnmeter weapon.
void function RegisterDummyBoost()
{
    BurnReward burnReward
    burnReward.id = burn.allCards.len() // Length of allCards array
    burnReward.ref = "burnmeter_random_dummy"
    burnReward.localizedName = "#BURNMETER_RANDOM_FOIL"
    burnReward.description = "#BURNMETER_RANDOM_FOIL_DESC"
    burnReward.image = $"rui/menu/boosts/boost_random"
    burnReward.cost = 0.5
    burnReward.userType = eBurnMeterRewardAvailableFor.PILOT_AND_TITAN
    burnReward.weaponName = "mp_ability_burncardweapon"
    burnReward.extraWeaponMod = "burnmeter_random_foil"
    burnReward.activationText = "#BURNMETER_RANDOM_FOIL_DESC"
    burnReward.skinIndex = 11

    burn.burnRewards[burnReward.ref] <- burnReward
    burn.allCards.append( burnReward )
    #if DEV
    printt( "[BurnCardDiceRoll] Added Dummy Boost Reward: " + burnReward.ref )
    #endif
}
// Add some vanilla boosts after checks
void function AddVanillaBurnReward( string ref, int weight )
{
    BoostWeight[ref] <- weight
    AllowedBoosts.append( ref )
}
// Add custom boost
//void function AddCustomBurnReward(string ref, int weight, string localizedName, string description, asset image, int userType, string activationText, void functionref( entity ) ornull rewardCallback )
void function AddCustomBurnReward( string ref, int weight, string localizedName, string activationText, asset image, void functionref( entity ) ornull rewardCallback )
{
    BurnReward burnReward
    burnReward.id = burn.allCards.len() // Length of allCards array
    burnReward.ref = ref
    burnReward.localizedName = localizedName
    burnReward.description = "" // unused by custom announcement
    burnReward.image = image // menu image, can be used for large announcements
    burnReward.cost = 0.5
    burnReward.userType = eBurnMeterRewardAvailableFor.PILOT_ONLY // Only Pilots can use Boosts normally.
    burnReward.weaponName = "mp_ability_burncardweapon"
    burnReward.extraWeaponMod = ""
    burnReward.activationText = activationText
    burnReward.skinIndex = 11
    burnReward.rewardAvailableCallback = rewardCallback

    burn.burnRewards[burnReward.ref] <- burnReward
    burn.allCards.append( burnReward )
    AllowedBoosts.append( burnReward.ref )
    BoostWeight[burnReward.ref] <- weight
    #if DEV
    printt( "[BurnCardDiceRoll] Added Boost Reward: " + ref )
    #endif
}

BurnReward function CreateCustomBurnCard( entity player )
{
    return BurnReward_GetByRef( "burnmeter_random_dummy" )
}
// ======================= RANDOM BOOST LOGIC =======================
void function GiveRandomBoostPlayer( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] Calling Random Boost!" )
    printt( "[BurnCardDiceRoll] Weight sum: ", file.weightSum )
    #endif
    if ( AllowedBoosts.len() == 0 )
    {
        printt( "[BurnCardDiceRoll] Warning: No boosts in table! Aborting!" )
        return
    }

    string ref
    if ( GetConVarBool( "sv_bc_use_weights" ) )
    {
        int randNum = 0
        int n = 0

        if ( AllowedBoosts.len() > 1 )
        {
            randNum = RandomIntRange( 1, file.weightSum )

            foreach ( string boost, int weight in BoostWeight )
            {
                n += weight
                if ( n >= randNum )
                {
                    ref = boost
                    break
                }
            }
        }
        else
        {
            ref = AllowedBoosts.getrandom()
        }
    }
    else
    {
        ref = AllowedBoosts.getrandom()
    }
    #if DEV
    printt( "[BurnCardDiceRoll] Selected: " + ref )
    printt( "[BurnCardDiceRoll] Weight: " + BoostWeight[ref] )
    #endif

    thread CreateBurnCardAndAnnouncement( player, ref )
}

void function CreateBurnCardAndAnnouncement( entity player, string ref )
{
    // Call non mp_ability_burncardweapon functions
    switch ( ref )
    {
        case "burnmeter_holopilot_nova":
            if ( PlayerCanUseDecoy( player ) )
            {
                waitthread BurnCardAnnouncement( player, ref )
                CreateHoloPilotDecoys( player, 3 )
                return
            }
            else
            {
                // If there's only one boost allowed, call a fallback or you'll stuck in loop.
                if ( AllowedBoosts.len() > 1 )
                {
                    #if DEV
                    printt( "[BurnCardDiceRoll] Can't use this boost now, roll again!" )
                    #endif
                    GiveRandomBoostPlayer( player )
                    return              
                }
                else
                {
                    #if DEV
                    printt( "[BurnCardDiceRoll] Can't use this boost now, fallback to amped weapons!" )
                    #endif
                    ref = "burnmeter_amped_weapons" 
                }
            }
            break

        case "burnmeter_ticks":
        case "burnmeter_hard_cover":
            //waitthread BurnCardAnnouncement( player, ref ) // covered by using them.
            thread UseThrownableBoost( player, ref )
            return

        case "burnmeter_ap_turret_weapon":
        case "burnmeter_at_turret_weapon":
            if ( PlayerCanUseDecoy( player ) && !player.IsWallHanging() && !player.IsWallRunning() /*&& player.IsOnGround()*/ )
            {
                if ( GetConVarBool( "sv_bc_autouse_deployable" ) )
                    waitthread BurnCardAnnouncement( player, ref )
                
                thread SpawnBoostTurret( player, ref )
                return
            }
            else
            {
                // If there's only one boost allowed, call a fallback or you'll stuck in loop.
                if ( AllowedBoosts.len() > 2 ) // HACK FRAUD!
                {
                    #if DEV
                    printt( "[BurnCardDiceRoll] Can't use this boost now, roll again!" )
                    #endif
                    GiveRandomBoostPlayer( player )
                    return              
                }
                else
                {
                    #if DEV
                    printt( "[BurnCardDiceRoll] Can't use this boost now, fallback to amped weapons!" )
                    #endif
                    ref = "burnmeter_amped_weapons" 
                }
            }
            break
    }

    waitthread BurnCardAnnouncement( player, ref )
    RunBurnCardUseFunc( player, ref )
}

void function BurnCardAnnouncement( entity player, string ref )
{
    BurnReward selectedBoost = BurnReward_GetByRef( ref )
    #if SERVERTRANSLATION
    string TranslatedName = ServerLocalizeTokenForClient( player, selectedBoost.localizedName, NSGetCurrentModName() )
    string TranslatedDesc = ServerLocalizeTokenForClient( player, selectedBoost.activationText, NSGetCurrentModName() )
    NSSendAnnouncementMessageToPlayer( player, TranslatedName, TranslatedDesc, <0.92, 0.23, 0.02>, 1, eAnnouncementStyle.ANNOUNCEMENT_STYLE_SWEEP )
    #else
    // Check for missing strings and replace them?
    NSSendAnnouncementMessageToPlayer( player, selectedBoost.localizedName, selectedBoost.activationText, <0.92, 0.23, 0.02>, 1, eAnnouncementStyle.ANNOUNCEMENT_STYLE_SWEEP )
    #endif
    if ( GetConVarBool( "sv_bc_announce_boost" ) )
        thread ServerBroadcastBoost( player, selectedBoost )
}
// COD-style server announcement.
void function ServerBroadcastBoost( entity player, BurnReward selectedBoost )
{
    wait 2.0
    // CallingCard struct uses asset type for images, but custom announcement expects string.
    // Let's convert it here and announcement will convert it back...
    CallingCard card = PlayerCallingCard_GetActive( player )
    string CardImagePath = card.image.tostring()
    CardImagePath = CardImagePath.slice( 2, CardImagePath.len() - 1 )

    #if SERVERTRANSLATION
    string TranslatedName = ServerLocalizeTokenForClient( player, selectedBoost.localizedName, NSGetCurrentModName() )
    #endif
        
    foreach ( entity otherPlayer in GetPlayerArray() )
    {
        // Conflicts with normal player announcement.
        if ( otherPlayer != player )
        {
            EmitSoundOnEntityOnlyToPlayer( otherPlayer, otherPlayer, "UI_InGame_FD_InfoCardSlideIn" )
            #if SERVERTRANSLATION
            NSSendLargeMessageToPlayer( otherPlayer, player.GetPlayerName(), TranslatedName, 5.0, CardImagePath )
            #else
            NSSendLargeMessageToPlayer( otherPlayer, player.GetPlayerName(), selectedBoost.localizedName, 5.0, CardImagePath )
            #endif
        }
    }
}

void function BurnCardOnBoostFailThread( entity player )
{
    NSSendPopUpMessageToPlayer( player, "#BOOST_STORE_AMPED_FAIL" )
    wait 5.0
    NSSendPopUpMessageToPlayer( player, "#COOP_WAVE_TRY_AGAIN" )
    // Give another boost
    PlayerInventory_PushInventoryItemByBurnRef( player, "burnmeter_random_dummy" )
    EmitSoundOnEntityOnlyToPlayer( player, player, "UI_TitanBattery_Pilot_PickUp" )
}

// ======================= AUTO-USE =======================
// Turrets
void function SpawnBoostTurret( entity player, string itemRef )
{
    WaitFrame()
    if ( GetConVarBool( "sv_bc_autouse_deployable" ) )
    {
        int nodeCount = GetNodeCount()
        vector plOrigin = player.GetOrigin()

        if ( nodeCount <= 0 )
        {
            #if DEV
            printt( "[BurnCardDiceRoll] Warning! No nav nodes found, aborting!" )
            #endif
            PlayerInventory_PushInventoryItemByBurnRef( player, itemRef )
            return
        }   
        
        array<vector> spawn_nodes
        int node = GetNearestNodeToPos( player.GetOrigin() )

        for ( int nodeIdx = 0; nodeIdx < nodeCount; nodeIdx++ )
        {
            if ( DistanceSqr( GetNodePos( node ), GetNodePos( nodeIdx ) ) <= 6400 )
            {
                #if DEV
                DebugDrawBoxSimple( GetNodePos( nodeIdx ), Vector(-30,-30,0), Vector(30,30,60), 100, 100, 0, 100, 10.0 )  
                #endif

                // Check for blocking
                TraceResults traceResult = TraceHull( GetNodePos( nodeIdx ), GetNodePos( nodeIdx ), Vector(-30,-30,0), Vector(30,30,60), player, TRACE_MASK_SOLID | TRACE_MASK_SHOT, TRACE_COLLISION_GROUP_NONE )

                if ( traceResult.hitEnt == null )
                {
                    spawn_nodes.append( GetNodePos( nodeIdx ) )
                }
            }
        }

        #if DEV
        printt( "[BurnCardDiceRoll] Node table size:", spawn_nodes.len() )
        #endif

        vector spawnpos

        if ( spawn_nodes.len() == 0 )
        {
            // Try player origin
            spawnpos = OriginToGround( plOrigin )
            // Check for blocking
            TraceResults traceResult = TraceHull( spawnpos, spawnpos, Vector(-30,-30,0), Vector(30,30,60), player, TRACE_MASK_SOLID | TRACE_MASK_SHOT, TRACE_COLLISION_GROUP_NONE )
            if ( traceResult.hitEnt != null )
            {
                printt( "[BurnCardDiceRoll] Spawn position is blocked! Position: ", spawnpos )
                #if DEV
                DebugDrawBoxSimple( spawnpos, Vector(-30,-30,0), Vector(30,30,60), 255, 0, 0, 100, 10.0 )
                #endif
            }
        }
        else
        {
            spawnpos = spawn_nodes.getrandom()
        }

        #if DEV
        printt( "[BurnCardDiceRoll] Spawn position: ", spawnpos )
        printt( "[BurnCardDiceRoll] Player Angles: ", player.GetAngles() )
        #endif

        wait 0.5

        entity turret = CreateEntity( "npc_turret_sentry" )
        turret.SetOrigin( spawnpos )
        turret.SetAngles( Vector( player.GetAngles().x, player.GetAngles().y, 0 ) )
        turret.SetBossPlayer( player )
        turret.ai.preventOwnerDamage = true
        turret.StartDeployed()
        SetTeam( turret, player.GetTeam() )
        EmitSoundOnEntity( turret, "Boost_Card_SentryTurret_Deployed_3P" )
        player.Signal( "DeploySentryTurret", { turret = turret } )
        turret.kv.AccuracyMultiplier = DEPLOYABLE_TURRET_ACCURACY_MULTIPLIER

        if ( itemRef == "burnmeter_ap_turret_weapon" )
        {
            SetSpawnOption_AISettings( turret, "npc_turret_sentry_burn_card_ap" )
        }
        else if ( itemRef == "burnmeter_at_turret_weapon" )
        {
            SetSpawnOption_AISettings( turret, "npc_turret_sentry_burn_card_at" )
        }

        DispatchSpawn( turret )

        if ( turret.Dev_GetAISettingByKeyField( "cleanup_between_rounds" ) == null || turret.Dev_GetAISettingByKeyField( "cleanup_between_rounds" ) == 1 )
			thread TrapDestroyOnRoundEnd( player, turret )

        turret.Anim_Play( "deploy" )

        thread KillTurretAfterDelay( turret )
        thread TrackTurretDeath( player, turret )
        thread DestroyOnDeathDelayed( turret, 0.15 )
    }
    else
    {
        PlayerInventory_PushInventoryItemByBurnRef( player, itemRef )
    }
}
// Taken from mp_ability_turretweapon.nut
void function KillTurretAfterDelay( entity turret )
{
	turret.EndSignal( "OnDeath" )

	float delay = expect float( turret.Dev_GetAISettingByKeyField( "turret_lifetime" ) )
	if ( delay <= 0 )
		return

	wait delay
	turret.Die()
}
void function TrackTurretDeath( entity ownerPlayer, entity turret )
{
	turret.EndSignal( "OnDestroy" )
	ownerPlayer.EndSignal( "OnDestroy" )

	AddToScriptManagedEntArray( ownerPlayer.p.turretArrayId, turret )

	OnThreadEnd
    (
		function() : ( turret, ownerPlayer )
		{
			if ( IsValid( ownerPlayer ) )
			{
				CalculatePlayerTurretCount( ownerPlayer )
			}
		}
	)

	WaitForever()
}
void function DestroyOnDeathDelayed( entity turret, float delay )
{
	turret.EndSignal( "OnDestroy" )
    
	turret.WaitSignal( "OnDeath" )
	wait delay

	turret.Destroy()
}
// Thrownables
void function UseThrownableBoost( entity player, string itemRef )
{
    WaitFrame()
    PlayerInventory_PushInventoryItemByBurnRef( player, itemRef )
    if ( GetConVarBool( "sv_bc_autouse_deployable" ) )
    {
        BurnReward burnReward = BurnReward_GetByRef( itemRef )
        string weaponRef = burnReward.weaponName
        wait 1.0
        player.SetActiveWeaponByName( weaponRef )
    }
}
// ============================================================
// Adding player mods
void function AddPoseModLifeLong( entity player, string posemod )
{        
    player.s.bc_storedPlayerStandMods <- player.GetPlayerModsForPos( PLAYERPOSE_STANDING )
    player.s.bc_storedPlayerCrouchMods <- player.GetPlayerModsForPos( PLAYERPOSE_CROUCHING )
    player.s.bc_storedPlayerStandMods.append(posemod)
    player.s.bc_storedPlayerCrouchMods.append(posemod)
    player.SetPlayerSettingPosMods( PLAYERPOSE_STANDING, player.s.bc_storedPlayerCrouchMods )
	player.SetPlayerSettingPosMods( PLAYERPOSE_CROUCHING, player.s.bc_storedPlayerCrouchMods )
    delete player.s.bc_storedPlayerStandMods
    delete player.s.bc_storedPlayerCrouchMods

    if ( !( "RemovePosModOnDeath" in player.s ) )
    {
        #if DEV
        printt( "[BurnCardDiceRoll] RemovePosModOnDeath doesn't exist in player struct, creating new one." )
        #endif
        player.s.RemovePosModOnDeath <- []
    }

    player.s.RemovePosModOnDeath.append(posemod)

    if ( player.s.RemovePosModOnDeath.len() > 0 )
    {
        #if DEV
        printt("[BurnCardDiceRoll] RemovePosModOnDeath items:")
        #endif
        foreach ( string posmod in player.s.RemovePosModOnDeath )
        {
            printt(posmod)
        }
    }
}
// ======================= CALLBACKS =======================
// First spawn callback
void function BurnCardOnPlayerFirstSpawn( entity player )
{
	AddPlayerMovementEventCallback( player, ePlayerMovementEvents.JUMP, BurnCardOnPlayerJump )
    AddPlayerMovementEventCallback( player, ePlayerMovementEvents.LEAVE_GROUND, BurnCardOnPlayerJump )
}
// Pilot jump callback
void function BurnCardOnPlayerJump( entity player )
{
    if ( IsPilot(player) )
    {
        if ( "bc_spectre_camo" in player.s )
        {
            if ( player.s.bc_spectre_camo == true )
                EmitSoundOnEntity( player, "spectre_servo_superjump" )
        }
    }
}
// Taking damage callback
void function BurnCardOnTakeDamage( entity player, var damageInfo )
{
    // Pilot only
    if ( IsInstantDeath( damageInfo ) || DamageInfo_GetForceKill( damageInfo ) || player.IsTitan() )
		return
    
    if ( player.GetHealth() - DamageInfo_GetDamage( damageInfo ) <= 0 )
    {
        if ( "bc_lifesave_shift" in player.s )
        {
            if ( player.s.bc_lifesave_shift == true )
            {
                thread PrePhaseShiftHolsterThread( player )
                DamageInfo_SetDamage( damageInfo, 1 ) // prevent player from dying, but if we set it to 0, player won't receive any knockback from damage source
                player.s.bc_lifesave_shift = false // Block only one death
                return
            }
        }
        if ( "bc_lifesave_rewind" in player.s )
        {
            if ( player.s.bc_lifesave_rewind == true )
            {
                PlayerUsesPhaseRewindBurncard( player )
                DamageInfo_SetDamage( damageInfo, 0 )
                player.s.bc_lifesave_rewind = false // Block only one death
                return
            }
        }
    }
}
void function PrePhaseShiftHolsterThread( entity player )
{
    player.HolsterWeapon()
    PhaseShift( player, 0, 3.0 )
    player.SetHealth( player.GetMaxHealth() )
    wait 3.0
    player.DeployWeapon()
}
// Death callback
void function BurnCardDeathCallback( entity player, var damageInfo )
{  
    // Spectre Camo
    if ( "bc_spectre_camo" in player.s )
    {
        if ( "bc_spectre_proxy" in player.s )
        {
            if ( player.s.bc_spectre_proxy != -1 )
            {
                entity spectreProxy = GetEntByIndex( player.s.bc_spectre_proxy )

                if ( IsValid( spectreProxy ) )
                    spectreProxy.Destroy()

                player.SetModel( $"models/robots/spectre/imc_spectre.mdl" )
                player.Show()

                player.s.bc_spectre_proxy = -1
            }
        }
        player.s.bc_spectre_camo = false
    }
    if ( "RemovePosModOnDeath" in player.s )
    {
        player.s.bc_storedPlayerStandMods <- player.GetPlayerModsForPos( PLAYERPOSE_STANDING )
        player.s.bc_storedPlayerCrouchMods <- player.GetPlayerModsForPos( PLAYERPOSE_CROUCHING )

        foreach ( string posmod in player.s.RemovePosModOnDeath )
        {
            var index_stand = player.s.bc_storedPlayerStandMods.find( posmod )
            var index_crouch = player.s.bc_storedPlayerCrouchMods.find( posmod )

            if ( index_stand != -1 )
                player.s.bc_storedPlayerStandMods.remove(index_stand)

            if ( index_crouch != -1 )
                player.s.bc_storedPlayerCrouchMods.remove(index_crouch)
        }

        player.SetPlayerSettingPosMods( PLAYERPOSE_STANDING, player.s.bc_storedPlayerCrouchMods )
        player.SetPlayerSettingPosMods( PLAYERPOSE_CROUCHING, player.s.bc_storedPlayerCrouchMods )
        delete player.s.bc_storedPlayerStandMods
        delete player.s.bc_storedPlayerCrouchMods

        player.s.RemovePosModOnDeath = []
    }
    else
    {
        player.s.RemovePosModOnDeath <- []
    }
    // Vanilla server flags
    if ( "bc_serverflags" in player.s )
    {
        TakeServerFlag( player, player.s.bc_serverflags )
        player.s.bc_serverflags = 0
    }
    else
    {
        player.s.bc_serverflags <- 0
    }
    // Satellite Uplink
    if ( "bc_sonar_forever" in player.s )
    {
        player.s.bc_sonar_forever = false
    }
    // Spider Sense
    if ( "bc_pilot_warning" in player.s )
    {
        player.s.bc_pilot_warning = false
    }
    // Phase Lifesaver
    if ( "bc_lifesave_shift" in player.s )
    {
        player.s.bc_lifesave_shift = false
    }
    if ( "bc_lifesave_rewind" in player.s )
    {
        player.s.bc_lifesave_rewind = false
    }
}
// Executions callback
void function BurnCardOnSyncedMelee( SyncedMeleeChooser actions, SyncedMelee action, entity player, entity enemy )
{
    thread BurnCardOnSyncedMeleeThreaded( player, enemy )
}
void function BurnCardOnSyncedMeleeThreaded( entity player, entity enemy )
{
    player.EndSignal( "OnDeath" )
    player.EndSignal( "OnDestroy" )
    
    player.WaitSignal( "SyncedMeleeComplete" )
    // Check for infinite cloak
    if ( IsPilot(player) && player.cloakedForever && !IsCloaked( player ) )
    {
        EnableCloakForever( player )
    }
}
// Respawn callback
void function BurnCardOnPilotRespawn( entity player )
{  
    if ( "bc_rematch" in player.s )
    {
        if ( IsPilot( player ) && player.s.bc_rematch == true )
        {
            #if DEV
            printt( "[BurnCardDiceRoll] ", player, " spawned as pilot with rematch checked!" )
            #endif
            thread SetupPilotSpawnOnRematch( player )
            entity killer = player.p.lastKiller
            if ( IsValid( killer ) )
            {
                // This should show message to player killer that we spawn at same position.
                if ( killer.IsPlayer() )
                {
                    // BurnCardRematch doesn't have correct translations.
                    // MessageToPlayer( killer, eEventNotifications.BurnCardRematch, player )
                    NSSendPopUpMessageToPlayer( killer, format( "%s %s", ServerLocalizeTokenForClient( killer, "#BC_REMATCH_WARNING", NSGetCurrentModName() ), player.GetPlayerName() ) )
                }
            }
            PlayFXOnEntity( SHIFTER_APPEAR_FX, player )
            EmitSoundOnEntityOnlyToPlayer( player, player, "Pilot_PhaseShift_End_1P" )
            EmitSoundOnEntityExceptToPlayer( player, player, "Pilot_PhaseShift_End_3P" )
        }
        player.s.bc_rematch = false
    }
    // HACK: Fix AIs not always showing on minimap after removing Satellite Uplink.
    GivePassive( player, ePassives.PAS_MINIMAP_AI )
    // Restore player name visibility after Spectre Camo.
    player.SetNameVisibleToEnemy( true )
    thread BurnCardOnAnimInterruption( player )
    thread BurnCardOnApplyBatteryToPort( player )
}
// Loop for scripted anim interruption
// Also called on Titan embark/disembark
void function BurnCardOnAnimInterruption( entity player )
{
    player.EndSignal( "OnDeath" )
    player.EndSignal( "OnDestroy" )

    while ( true )
    {
        player.WaitSignal( "ScriptAnimStop" )
        // Check for infinite cloak
        if ( IsPilot(player) && player.cloakedForever && !IsCloaked( player ) )
        {
            EnableCloakForever( player )
        }
        if ( IsPilot(player) && "bc_spectre_camo" in player.s )
        {
            if ( player.s.bc_spectre_camo == true )
                player.Hide()
        }
    }
}
// Loop for FW battery port
void function BurnCardOnApplyBatteryToPort( entity player )
{
    player.EndSignal( "OnDeath" )
    player.EndSignal( "OnDestroy" )

    while ( true )
    {
        player.WaitSignal( "BatteryActivate" ) // this is registered in _gamemode_fw.nut!
        // Check for infinite cloak
        if ( IsPilot(player) && player.cloakedForever && !IsCloaked( player ) )
        {
            EnableCloakForever( player )
        }
    }
}
// Weapon drop callback
void function CodeCallback_BoostedWeaponDropped( entity weapon )
{
    // Remove permanent amped weapon burn mod
    if ( IsValid( weapon ) )
    {
        float ampDurationLeft = weapon.GetScriptTime0() - Time() // amped weapon timer!
        if ( ampDurationLeft <= 0 )
        {
            foreach ( string mod in GetWeaponBurnMods( weapon.GetWeaponClassName() ) )
			    weapon.RemoveMod( mod )

		    weapon.SetScriptFlags0( weapon.GetScriptFlags0() & ~WEAPONFLAG_AMPED )
        }
    }
}
// Titan Doomed callback
void function BurnCardOnTitanDoomed( entity titan, var damageInfo )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", titan, "BurnCardOnTitanDoomed Callback!" )
    #endif
    if ( !IsAlive( titan ) )
		return

	entity soul = titan.GetTitanSoul()

    if ( !IsValid( soul ) ) //Ejecting
		return

    if ( soul.GetTargetName() == "empTitanSoul" )
    {
        #if DEV
        printt( "[BurnCardDiceRoll] ", soul, "is marked as EMP, wait for titan undoom signal!" )
        #endif
        // check for titan undoom
        thread BurnCardOnTitanDoomedThink( soul )
    }
}
void function BurnCardOnTitanDoomedThink( entity soul )
{
    soul.EndSignal( "OnDeath" )
	soul.EndSignal( "OnDestroy" )

    entity titan = soul.GetTitan()
    titan.EndSignal( "OnDeath" )
    titan.EndSignal( "OnDestroy" )

    titan.WaitSignal( "TitanUnDoomed" )
    #if DEV
    printt( "[BurnCardDiceRoll] ", titan, "TitanUnDoomed signal!" )
    #endif
    thread EMPTitanThinkConstant( titan )
}
// Titan embark callback
void function BurnCardOnPilotBecomesTitan( entity player, entity titan )
{
    // Temporary disable Arc field, delete it from titan, put a new one on player.
    entity soul = player.GetTitanSoul()
    #if DEV
    printt( "[BurnCardDiceRoll] Player Soul: ", player.GetTitanSoul() )
    #endif
    if ( IsValid( soul ) )
    {
        if ( soul.GetTargetName() == "empTitanSoul" )
        {
            if ( !soul.IsDoomed() )
                thread EMPTitanThinkConstant( player )
            else
                thread BurnCardOnTitanDoomedThink( soul )
        }
    }

    if ( "bc_titanboosts_player" in player.s )
    {
        if ( player.s.bc_titanboosts_player.len() < 1 )
            return

        foreach ( string titanboost in player.s.bc_titanboosts_player )
        {
            #if DEV
            printt( "[BurnCardDiceRoll] titanboost: ", titanboost )
            #endif
            AddTitanBoost( player, titanboost )
        }

        player.s.bc_titanboosts_player = []
    }
    // Spectre camo check
    if ( "bc_spectre_camo" in player.s )
    {
        if ( player.s.bc_spectre_camo == true )
        {
            if ( "bc_spectre_proxy" in player.s )
            {
                if ( player.s.bc_spectre_proxy != -1 )
                {
                    entity spectreProxy = GetEntByIndex( player.s.bc_spectre_proxy )

                    if ( IsValid( spectreProxy ) )
                        spectreProxy.Destroy()

                    player.s.bc_spectre_proxy = -1
                }
            }
            // Unhide real player
            player.Show()
        }
    }
}
// Titan disembark callback
void function BurnCardOnTitanBecomesPilot( entity player, entity titan )
{
    if( titan.GetTitanSoul().IsEjecting() ) // this time titan is ejecting
    {
        TakePassive( player, ePassives.PAS_NUCLEAR_CORE )
    }
    // Temporary disable Arc field, delete it from player, put a new one on titan.
    entity soul = titan.GetTitanSoul()
    #if DEV
    printt( "[BurnCardDiceRoll] Titan Soul: ", titan.GetTitanSoul() )
    #endif
    if ( soul.GetTargetName() == "empTitanSoul" && !soul.IsDoomed() )
    {
        soul.Signal( "StopEMPField" )
        thread EMPTitanThinkConstant( titan )
        SetTargetName( titan, "empTitan" )
        SetTargetName( player, "" )
    }
    // Spectre camo check
    if ( "bc_spectre_camo" in player.s )
    {
        if ( player.s.bc_spectre_camo == true )
        {
            entity follower = CreateSpectreProxy( player )
            if ( !( "bc_spectre_proxy" in player.s ) )
            {
                player.s.bc_spectre_proxy <- follower.GetEntIndex()
            }
            else
            {
                player.s.bc_spectre_proxy = follower.GetEntIndex()
            }
            // Hiding player model at ScriptAnimStop.
        }
    }
}
// Titan rodeo start callback
void function BurnCardOnRodeoStart( entity rider, entity titan )
{
    if ( !IsAlive( titan ) )
		return
    
    entity soul = titan.GetTitanSoul()

    if ( IsValid( soul ) )
    {
        if ( "bc_amped_rider" in soul.s )
        {
            if ( soul.s.bc_amped_rider == true )
            {
                if ( IsValid( rider ) )
                {
                    if ( !( "hasPermanentAmpedWeapons" in rider.s ) || !rider.s.hasPermanentAmpedWeapons )
                    {
                        thread AddBurnModsToRiderWeapons( rider )
                    }
                }
            }
        }
    }
}
void function AddBurnModsToRiderWeapons( entity rider )
{
	rider.EndSignal( "OnDeath" )
    rider.EndSignal( "OnDestroy" )
    rider.EndSignal( "RodeoOver" )

    array<entity> weapons = rider.GetMainWeapons()
    weapons.append( rider.GetOffhandWeapon( OFFHAND_ORDNANCE ) )
    
    #if DEV
    printt( "[BurnCardDiceRoll] Amping weapons for player: ", rider )
    #endif

    OnThreadEnd
    (
        function () : ( rider, weapons )
        {
            #if DEV
            printt( "[BurnCardDiceRoll] Stop amping weapons for player: ", rider )
            #endif

            foreach ( entity weapon in weapons )
            {
                if ( !IsValid( weapon ) )
                    continue

                // Don't remove burn mods if player has permanent amped weapons boost.
                entity weaponOwner = weapon.GetWeaponOwner()

                if ( weaponOwner.IsPlayer() )
                {
                    if ( !( "hasPermanentAmpedWeapons" in weaponOwner.s ) || !weaponOwner.s.hasPermanentAmpedWeapons )
                    {
                        foreach ( string mod in GetWeaponBurnMods( weapon.GetWeaponClassName() ) )
                            weapon.RemoveMod( mod )

                        weapon.SetScriptFlags0( weapon.GetScriptFlags0() & ~WEAPONFLAG_AMPED )
                    }
                }
            }
        }
    )

	foreach ( entity weapon in weapons )
	{
		weapon.RemoveMod( "silencer" ) // both this and the burnmod will override firing fx, if a second one overrides this we crash
		foreach ( string mod in GetWeaponBurnMods( weapon.GetWeaponClassName() ) )
		{
			// catch incompatibilities just in case
			try
			{
				weapon.AddMod( mod )
			}
			catch( ex )
			{
				weapons.removebyvalue( weapon )
			}
		}

		weapon.SetScriptFlags0( weapon.GetScriptFlags0() | WEAPONFLAG_AMPED )
		AddCallback_OnWeaponDropped( CodeCallback_BoostedWeaponDropped )
	}

    WaitForever()
}
// Titan rodeo end callback
void function BurnCardOnRodeoEnd( entity rider, entity titan )
{
    // Check for infinite cloak
    if ( IsPilot( rider ) && rider.cloakedForever && !IsCloaked( rider ) )
    {
        EnableCloakForever( rider )
    }
}
// Apply battery to Titan callback
void function BurnCardOnApplyBattery( entity rider, entity titan, entity battery )
{
    // Check for infinite cloak
    if ( IsPilot( rider ) && rider.cloakedForever && !IsCloaked( rider ) )
    {
        EnableCloakForever( rider )
    }
}
// Titanfall callback
void function BurnCardOnNewTitanLoadout( entity titan, TitanLoadoutDef loadout )
{
    thread BurnCardOnNewTitanLoadoutThreaded( titan, loadout )
}
void function BurnCardOnNewTitanLoadoutThreaded( entity titan, TitanLoadoutDef loadout )
{
    #if DEV
    printt( "[BurnCardDiceRoll] BurnCardOnNewTitanLoadout called!!!" )
    #endif
    entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) ) //Ejecting
		return

    wait 0.5 // Wait untill player become titan owner
    entity player = titan.GetBossPlayer()

    if ( IsValid( player ) )
    {
        if ( "bc_titanboosts" in player.s )
        {
            if ( player.s.bc_titanboosts.len() < 1 )
                return

            foreach ( string titanboost in player.s.bc_titanboosts )
            {
                if ( AddTitanBoostOnSpawn( soul, titanboost ) )
                {
                    var index_boost = player.s.bc_titanboosts.find( titanboost )
                    #if DEV
                    printt( "[BurnCardDiceRoll] Titan Boost: ", titanboost, "Index: ", index_boost )
                    #endif
                }
            }

            player.s.bc_titanboosts = []
        }
    }
}
// Titan boosts applied on Titan spawn
bool function AddTitanBoostOnSpawn( entity soul, string titanboost )
{   
    switch ( titanboost )
    {
        case "bc_core_charged":
            entity titan = soul.GetTitan()
            if ( titan.GetOffhandWeapon( OFFHAND_EQUIPMENT ) != null )
            {
                SoulTitanCore_SetNextAvailableTime( soul, 1.0 ) // 1.0 - 100%
                return true
            }
            return false

        case "bc_nuclear_core":
            soul.passives[ ePassives.PAS_NUCLEAR_CORE ] = true
            return true

        case "bc_titan_shield_regen":
            soul.passives[ ePassives.PAS_SHIELD_REGEN ] = true
            return true

        case "bc_titan_arc_field":
            SetTargetName( soul, "empTitanSoul" )
            entity titan = soul.GetTitan()
            thread EMPTitanThinkConstant( titan )
            return true

        case "bc_titan_amped_weapons":
            #if DEV
            printt( "[BurnCardDiceRoll] ", soul, "Amping Titan weapons..." )
            #endif
            entity titan = soul.GetTitan()
            foreach ( entity weapon in titan.GetMainWeapons() )
            {
                #if DEV
                printt( "[BurnCardDiceRoll] ", titan, "Weapon: " + weapon )
                #endif
		        foreach ( string mod in GetWeaponBurnMods( weapon.GetWeaponClassName() ) )
                {
                    #if DEV
                    printt( "[BurnCardDiceRoll] ", titan, "Burn Mod: " + mod )
                    #endif
			        weapon.AddMod( mod )
                }

                #if DEV
                printt( "[BurnCardDiceRoll] ", titan, "Weapon Mods: " )
                #endif
                foreach ( string mod in weapon.GetMods() )
                    printt( mod )
            }

            array<int> offhandSlots = [ OFFHAND_MELEE, OFFHAND_LEFT, OFFHAND_RIGHT, OFFHAND_ANTIRODEO, OFFHAND_INVENTORY ]
            foreach ( slot in offhandSlots )
            {
                entity weapon = titan.GetOffhandWeapon( slot )
                if ( IsValid( weapon ) )
                {
                    #if DEV
                    printt( "[BurnCardDiceRoll] ", titan, "Weapon: " + weapon )
                    #endif
                    foreach ( string mod in GetWeaponBurnMods( weapon.GetWeaponClassName() ) )
                    {
                        #if DEV
                        printt( "[BurnCardDiceRoll] ", titan, "Burn Mod: " + mod )
                        #endif
                        weapon.AddMod( mod )
                    }
                    if ( slot != OFFHAND_MELEE )
                    {
                        // Rearm offhands
                        int maxammo = weapon.GetWeaponPrimaryClipCountMax()
                        weapon.SetWeaponPrimaryClipCount( maxammo )
                    }
                    #if DEV
                    printt( "[BurnCardDiceRoll] ", titan, "Weapon Mods: " )
                    #endif
                    foreach ( string mod in weapon.GetMods() )
                        printt( mod )
                }
            }
            // Store amped smoke boost until titan will get one
            StoreTitanBoost( soul, "bc_titan_amped_smoke" )
            return true
    }
    return false
}
// Titan boosts applied on embarking Titan
void function AddTitanBoost( entity player, string titanboost )
{
    if ( player.IsTitan() )
    {
        switch ( titanboost )
        {
            case "bc_extra_dash":
                if ( GetCurrentPlaylistVarInt( "featured_mode_turbo_titans", 0 ) == 0 )
                {
                    array<string> settingsMods = player.GetPlayerSettingsMods()
                    
                    // Can't have multiple mods editing same value. Replacing Turbo Engine perk with burn card one.
                    if ( settingsMods.contains( "pas_mobility_dash_capacity" ) || settingsMods.contains( "pas_dash_recharge" ) )
                    {
                        #if DEV
                        printt( "[BurnCardDiceRoll] ", player, "Warning! Can't have multiple mods editing same value. Replace Turbo Engine perk with burn card one!" )
                        #endif
                        int index = settingsMods.find( "pas_mobility_dash_capacity" )
                        if ( index != -1 )
                            settingsMods.remove( index )

                        index = settingsMods.find( "pas_dash_recharge" )
                        if ( index != -1 )
                            settingsMods.remove( index )
                        
                        player.SetPlayerSettingsWithMods( player.GetPlayerSettings(), settingsMods )

                        entity soul = player.GetTitanSoul()
                        soul.passives[ ePassives.PAS_MOBILITY_DASH_CAPACITY ] = false
                        soul.passives[ ePassives.PAS_DASH_RECHARGE ] = false
                    }
                    settingsMods.append( "sflag_bc_dash_capacity" )
                    player.SetPlayerSettingsWithMods( player.GetPlayerSettings(), settingsMods )
                }
                return
        }
    }
}
// Storage for Titan boosts when Pilot doesn't have Titan.
void function StoreTitanBoost( entity player, string boostName )
{
    if ( !( "bc_titanboosts" in player.s ) )
    {
        #if DEV
        printt( "[BurnCardDiceRoll] ", player, "bc_titanboosts doesn't exist in entity struct, creating new one." )
        #endif
        player.s.bc_titanboosts <- []
    }
    // Apply this mod only once
    else
    {
        if ( player.s.bc_titanboosts.find( boostName ) != -1 )
        {
            #if DEV
            printt( "[BurnCardDiceRoll] ", player, "Already has ", boostName , " Boost!" )
            #endif
            thread BurnCardOnBoostFailThread( player )
            return
        }
    }
    player.s.bc_titanboosts.append( boostName )
}
// ======================= CUSTOM BOOSTS =======================
// ----------------- TF1 Burn Cards - Stealth ------------------
// Active Camo
void function PlayerUsesActiveCamo( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Active Camo Boost!" )
    #endif
    player.TakeOffhandWeapon( OFFHAND_SPECIAL )
    player.GiveOffhandWeapon( "mp_ability_cloak", OFFHAND_SPECIAL, [ "bc_super_cloak" ] )
}
// Ghost Squad
void function PlayerUsesGhostSquad( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Ghost Squad Boost!" )
    #endif
    if ( player.cloakedForever )
    {
        #if DEV
        printt( "[BurnCardDiceRoll] ", player, "Already has Ghost Squad Boost!" )
        #endif
        thread BurnCardOnBoostFailThread( player )
        return
    }
    EnableCloakForever( player )
}
// ----------------- TF1 Burn Cards - Speed ------------------
// Smuggled Stimulant
void function PlayerUsesSmuggledStimulant( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Smuggled Stimulant Boost!" )
    #endif
    player.TakeOffhandWeapon( OFFHAND_SPECIAL )
    player.GiveOffhandWeapon( "mp_ability_heal", OFFHAND_SPECIAL, [ "bc_super_stim" ] )
}
// Adrenaline Transfusion
void function PlayerUsesAdrenalineTransfusion( entity player )
{   
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Adrenaline Transfusion Boost!" )
    #endif
    if ( player.stimmedForever )
    {
        #if DEV
        printt( "[BurnCardDiceRoll] ", player, "Already has Adrenaline Transfusion Boost!" )
        #endif
        thread BurnCardOnBoostFailThread( player )
        return
    }
    EmitSoundOnEntityOnlyToPlayer( player, player, "pilot_stimpack_activate_1P" )
    StimPlayer( player, USE_TIME_INFINITE )
    player.stimmedForever = true
}
// Prosthetic Legs
void function PlayerUsesProstheticLegs( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Prosthetic Legs Boost!" )
    #endif
    // Apply this mod only once
    if ( "RemovePosModOnDeath" in player.s )
    {
        if ( player.s.RemovePosModOnDeath.find( "bc_fast_movespeed" ) != -1 )
        {
            #if DEV
            printt( "[BurnCardDiceRoll] ", player, "Already has Prosthetic Legs Boost!" )
            #endif
            thread BurnCardOnBoostFailThread( player )
            return
        }
    }
    AddPoseModLifeLong( player, "bc_fast_movespeed" )
}
// ----------------- TF1 Burn Cards - Intel ------------------
// Packet Sniffer
void function PlayerUsesPacketSniffer( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Packet Sniffer Boost!" )
    #endif
    player.EndSignal( "OnDeath" )
    player.EndSignal( "OnDestroy" )
    // Apply this mod only once
    if ( PlayerHasPassive( player, ePassives.PAS_AUTO_SONAR ) )
    {
        #if DEV
        printt( "[BurnCardDiceRoll] ", player, "Already has Packet Sniffer Boost!" )
        #endif
        thread BurnCardOnBoostFailThread( player )
        return
    }
    GivePassiveLifeLong( player, ePassives.PAS_AUTO_SONAR )
    thread SonarPulseForPlayer( player )
}
// Emit a single 2 second Sonar Pulse about every 6 seconds.
// For now, it works like a Map Hack, but without radar update.
// Should give sonar pulse only visible to owner?
void function SonarPulseForPlayer( entity player )
{
    player.EndSignal( "OnDeath" )
    player.EndSignal( "OnDestroy" )
    // If the user disconnects, we need to clean up hanging sonar effects, so hold relevant data here.
	int playerTeam = player.GetTeam()
	bool cleanup = false
	array<entity> entities, affectedEntities

    OnThreadEnd
    (
		function() : ( cleanup, playerTeam, affectedEntities )
		{
			if ( !cleanup ) // Map hack ended when sonar wasn't active, no cleanup needed
				return
			
			foreach ( entity ent in affectedEntities )
			{
				if ( IsValid( ent ) )
					SonarEnd( ent, playerTeam )
			}
			DecrementSonarPerTeam( playerTeam )
		}
	)

    while ( true )
    {
        EmitSoundOnEntityOnlyToPlayer( player, player, "Burn_Card_Map_Hack_Radar_Pulse_V1_1P" )

        entities = GetPlayerArray()
        entities.extend( GetNPCArray() )
        entities.extend( GetPlayerDecoyArray() )

        IncrementSonarPerTeam( playerTeam )

        if ( IsAlive( player ) ) // only owner can see the pulse
            Remote_CallFunction_Replay( player, "ServerCallback_SonarPulseFromPosition", player.GetOrigin().x, player.GetOrigin().y, player.GetOrigin().z, SONAR_GRENADE_RADIUS )
            
        foreach ( entity ent in entities )
        {
            if ( !IsValid( ent ) ) // Not sure why we can get invalid entities at this point
                continue

            if ( ent.GetTeam() != playerTeam )
            {
                    StatusEffect_AddTimed( ent, eStatusEffect.maphack_detected, 1.0, SONAR_PULSE_DELAY, 0.0 )
                    affectedEntities.append( ent )
                    SonarStart( ent, player.GetOrigin(), playerTeam, player )
            }
        }
        cleanup = true
        wait SONAR_PULSE_LENGTH

        DecrementSonarPerTeam( playerTeam )
        // JFS - loop through entities that were explicitly given sonar in case they switched teams during the wait
        foreach ( entity ent in affectedEntities )
        {
            if ( IsValid( ent ) )
                SonarEnd( ent, playerTeam )
        }
        cleanup = false
        affectedEntities.clear()
        wait SONAR_PULSE_DELAY - SONAR_PULSE_LENGTH
    }
}
// Satellite Uplink
// Normally players always see all AI enemies with "Minimap_AlwaysShow", but function ScanMinimap disables this behavior.
void function PlayerUsesSatelliteUplink( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Satellite Uplink Boost!" )
    #endif
    // Apply this mod only once
    if ( !( "bc_sonar_forever" in player.s ) )
    {
        player.s.bc_sonar_forever <- false
    }
    else
    {
        if ( player.s.bc_sonar_forever == true )
        {
            #if DEV
            printt( "[BurnCardDiceRoll] ", player, "Already has Satellite Uplink Boost!" )
            #endif
            thread BurnCardOnBoostFailThread( player )
            return
        }
    }
    player.s.bc_sonar_forever = true
    thread ScanMinimapForPlayersUntilDeath( player )
}
// Copied from _passives.gnut and modified
function ScanMinimapForPlayersUntilDeath( entity player )
{
	player.EndSignal( "OnDeath" )
    player.EndSignal( "OnDestroy" )
	for ( ;; )
	{
 		thread ScanMinimapForPlayers( player, true, 2.0 )
 		wait 10.0
 	}
}
function ScanMinimapForPlayers( entity player, bool playSound, float displayTime = 3.0 )
{
	// already has the passive?
	if ( PlayerHasPassive( player, ePassives.PAS_MINIMAP_ALL ) )
		return

	player.EndSignal( "OnDeath" )
    player.EndSignal( "OnDestroy" )

	int handle = player.GetEncodedEHandle()
	Remote_CallFunction_Replay( player, "ServerCallback_MinimapPulse", handle )

	OnThreadEnd(
		function () : ( player )
		{
			if ( IsValid( player ) )
				TakePassive( player, ePassives.PAS_MINIMAP_ALL )
		}
	)

	GivePassive( player, ePassives.PAS_MINIMAP_ALL )
	if ( playSound )
		EmitSoundOnEntityOnlyToPlayer( player, player, "Burn_Card_Map_Hack_Radar_Pulse_V1_1P" )
	wait displayTime
}
// Spider Sense
void function PlayerUsesSpiderSense( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Spider Sense Boost!" )
    #endif
    // Apply this mod only once
    if ( !( "bc_pilot_warning" in player.s ) )
    {
        player.s.bc_pilot_warning <- false
    }
    else
    {
        if ( player.s.bc_pilot_warning == true )
        {
            #if DEV
            printt( "[BurnCardDiceRoll] ", player, "Already has Spider Sense Boost!" )
            #endif
            thread BurnCardOnBoostFailThread( player )
            return
        }
    }
    player.s.bc_pilot_warning = true
    thread PilotWarningForPlayer( player )
}
void function PilotWarningForPlayer( entity player )
{
    player.EndSignal( "OnDeath" )
    player.EndSignal( "OnDestroy" )
    // If the user disconnects, we need to clean up hanging sonar effects, so hold relevant data here.
	int playerTeam = player.GetTeam()
    array<entity> entities

    while ( true )
    {       
        // Disable warnings when Phase Shifted.
        if ( !player.IsPhaseShifted() )
        {
            entities = GetPlayerArrayOfEnemies( playerTeam )
            #if DEV
            array<entity> enemies = GetNPCArrayEx( "any", TEAM_ANY, player.GetTeam(), player.GetOrigin(), PILOT_WARNING_RADIUS ) // for testing.
            entities.extend( enemies ) // for testing.
            #endif

            if ( entities.len() != 0 )
            {
                entity alarmenemy = GetClosest( entities, player.GetOrigin() )
                #if DEV
                printt( "[BurnCardDiceRoll] Enemy ", alarmenemy, "is too close to ", player, ", emit warning sounds!" )
                #endif
                // Not sure why we can get invalid entities at this point
                if ( IsValid( alarmenemy ) )
                {
                    if ( DistanceSqr( alarmenemy.GetOrigin(), player.GetOrigin() ) <= PILOT_WARNING_RADIUS_CLOSE * PILOT_WARNING_RADIUS_CLOSE )
                    {
                        // This sound is very quiet, is there a way to boost its volume (it has 700% volume in TF1), except play 7 sounds at once?
                        EmitSoundOnEntityOnlyToPlayer( player, player, "BurnCard_SpiderSense_CloseWarn" )
                        EmitSoundOnEntityOnlyToPlayer( player, player, "BurnCard_SpiderSense_CloseWarn" )
                        EmitSoundOnEntityOnlyToPlayer( player, player, "BurnCard_SpiderSense_CloseWarn" )
                        EmitSoundOnEntityOnlyToPlayer( player, player, "BurnCard_SpiderSense_CloseWarn" )
                        EmitSoundOnEntityOnlyToPlayer( player, player, "BurnCard_SpiderSense_CloseWarn" )
                        EmitSoundOnEntityOnlyToPlayer( player, player, "BurnCard_SpiderSense_CloseWarn" )
                        EmitSoundOnEntityOnlyToPlayer( player, player, "BurnCard_SpiderSense_CloseWarn" )
                    }
                    else if ( DistanceSqr( alarmenemy.GetOrigin(), player.GetOrigin() ) > PILOT_WARNING_RADIUS_CLOSE * PILOT_WARNING_RADIUS_CLOSE && DistanceSqr( alarmenemy.GetOrigin(), player.GetOrigin() ) < PILOT_WARNING_RADIUS * PILOT_WARNING_RADIUS )
                    {
                        // This sound is very quiet, is there a way to boost its volume (it has 500% volume in TF1), except play 5 sounds at once?
                        EmitSoundOnEntityOnlyToPlayer( player, player, "BurnCard_SpiderSense_DistantWarn" )
                        EmitSoundOnEntityOnlyToPlayer( player, player, "BurnCard_SpiderSense_DistantWarn" )
                        EmitSoundOnEntityOnlyToPlayer( player, player, "BurnCard_SpiderSense_DistantWarn" )
                        EmitSoundOnEntityOnlyToPlayer( player, player, "BurnCard_SpiderSense_DistantWarn" )
                        EmitSoundOnEntityOnlyToPlayer( player, player, "BurnCard_SpiderSense_DistantWarn" )
                    }
                }
            }
        }

        #if DEV
        printt( "[BurnCardDiceRoll] Waiting delay for", player )
        #endif
        wait PILOT_WARNING_DELAY
        #if DEV
        printt( "[BurnCardDiceRoll] Wait end!", player )
        #endif
    }
    #if DEV
    printt( "[BurnCardDiceRoll] Warning! PilotWarningForPlayer is out of loop!" )
    #endif
}
// Double Agent
void function PlayerUsesDoubleAgent( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Double Agent Boost!" )
    #endif
    // Apply this mod only once
    if ( player.GetNoTarget() )
    {
        #if DEV
        printt( "[BurnCardDiceRoll] ", player, "Already has Double Agent Boost!" )
        #endif
        thread BurnCardOnBoostFailThread( player )
        return
    }
    player.SetNoTarget( true )
}
// Conscription
void function PlayerUsesConscription( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Conscription Boost!" )
    #endif
    // Apply this mod only once
    if ( PlayerHasPassive( player, ePassives.PAS_CONSCRIPT ) )
    {
        #if DEV
        printt( "[BurnCardDiceRoll] ", player, "Already has Conscription Boost!" )
        #endif
        thread BurnCardOnBoostFailThread( player )
        return
    }
    GivePassiveLifeLong( player, ePassives.PAS_CONSCRIPT )
}
// WI-FI Virus
void function PlayerUsesWiFiVirus( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Wi-Fi Virus Boost!" )
    #endif
    // Apply this mod only once
    if ( PlayerHasPassive( player, ePassives.PAS_WIFI_SPECTRE ) )
    {
        #if DEV
        printt( "[BurnCardDiceRoll] ", player, "Already has Wi-Fi Virus Boost!" )
        #endif
        thread BurnCardOnBoostFailThread( player )
        return
    }
    GivePassiveLifeLong( player, ePassives.PAS_WIFI_SPECTRE )
}
// ----------------- TF1 Burn Cards - Misc ------------------
// Rematch
void function PlayerUsesRematch( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Rematch Boost!" )
    #endif
    if ( !( "bc_rematch" in player.s ) )
    {
        player.s.bc_rematch <- false
    }
    // Apply this mod only once
    else
    {
        if ( player.s.bc_rematch == true )
        {
            #if DEV
            printt( "[BurnCardDiceRoll] ", player, "Already has Rematch Boost!" )
            #endif
            thread BurnCardOnBoostFailThread( player )
            return
        }
    }
    player.s.bc_rematch = true
}
// Spectre Camo - server-side version. No effects.
void function PlayerUsesSpectreCamo( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Spectre Camo Boost!" )
    #endif
    if ( !( "bc_spectre_camo" in player.s ) )
    {
        player.s.bc_spectre_camo <- false
    }
    // Apply this mod only once
    else
    {
        if ( player.s.bc_spectre_camo == true )
        {
            #if DEV
            printt( "[BurnCardDiceRoll] ", player, "Already has Spectre Camo Boost!" )
            #endif
            thread BurnCardOnBoostFailThread( player )
            return
        }
    }
    player.s.bc_spectre_camo = true
    thread SpectreCamoThread( player )
}
void function SpectreCamoThread( entity player )
{
    EnableCloak( player, 1.5 )
    wait 1.0
    // SetPlayerSettings disables player mods, so they need to be saved and re-applied.
    player.s.spectre_storedPlayerSettingsMods <- player.GetPlayerSettingsMods()
    player.s.spectre_storedPlayerStandMods <- player.GetPlayerModsForPos( PLAYERPOSE_STANDING )
	player.s.spectre_storedPlayerCrouchMods <- player.GetPlayerModsForPos( PLAYERPOSE_CROUCHING )
    player.SetPlayerSettingsWithMods( "pilot_nomad_male", player.s.spectre_storedPlayerSettingsMods )
    player.SetPlayerSettingPosMods( PLAYERPOSE_STANDING, player.s.spectre_storedPlayerStandMods )
	player.SetPlayerSettingPosMods( PLAYERPOSE_CROUCHING, player.s.spectre_storedPlayerCrouchMods )
    entity follower = CreateSpectreProxy( player )
    if ( !( "bc_spectre_proxy" in player.s ) )
    {
        player.s.bc_spectre_proxy <- follower.GetEntIndex()
    }
    else
    {
        player.s.bc_spectre_proxy = follower.GetEntIndex()
    }
    player.SetNameVisibleToEnemy( false )
    player.Hide() // Doesn't hide weapon attachments, but disables jet boosts.
    wait 0.5
    EmitSoundOnEntityOnlyToPlayer( player, player, "cloak_interruptend_1P" )
    EmitSoundOnEntityExceptToPlayer( player, player, "cloak_interruptend_3P" )
}
entity function CreateSpectreProxy( entity player )
{
    entity follower = CreatePropDynamic( $"models/robots/spectre/imc_spectre.mdl", player.GetOrigin(), player.GetAngles() )
    follower.SetParent( player, "REF" )
    follower.SetBoneMerge( player )
    follower.MarkAsNonMovingAttachment()
    follower.RemoveFromSpatialPartition()
    follower.SetCanCloak( true )
    follower.SetScriptName( player.GetPlayerName() + "_spectremodel" )
    return follower
}
// ---------------- TF1 Burn Cards - Bonus -----------------
// TF1 Titan build time - 240 s
// TF1 Titan core build time - 200 s
// TF2 Titan build time - ~ 420 s
// Decisive Action - 40 seconds (TF1)
void function PlayerUsesDecisiveAction( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Decisive Action Boost!" )
    #endif
    AddFloatToEarnMeter( player, 0.15 )
}
// Pull Rank - 80 seconds (TF1)
void function PlayerUsesPullRank( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Pull Rank Boost!" )
    #endif
    AddFloatToEarnMeter( player, 0.3 )
}
void function AddFloatToEarnMeter( entity player, float amount ) // 1.0 - 100%
{
    if ( player.IsTitan() )
        AddCreditToTitanCoreBuilder( player, amount )    
    else if ( !IsAlive( player.GetPetTitan() ) )
        PlayerEarnMeter_AddOwnedFrac( player, amount )
    else
    {
        entity titan = player.GetPetTitan()
        AddCreditToTitanCoreBuilder( titan, amount )
    }
}
// Thin the Ranks
void function PlayerUsesThintheRanks( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Thin the Ranks Boost!" )
    #endif
    if ( PlayerHasServerFlag( player, SFLAG_HUNTER_GRUNT ) )
    {
        #if DEV
        printt( "[BurnCardDiceRoll] ", player, "Already has Thin the Ranks Boost!" )
        #endif
        thread BurnCardOnBoostFailThread( player )
        return
    }
    GiveServerFlagLifeLong( player, SFLAG_HUNTER_GRUNT )
}
// Urban Renewal
void function PlayerUsesUrbanRenewal( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Urban Renewal Boost!" )
    #endif
    if ( PlayerHasServerFlag( player, SFLAG_HUNTER_SPECTRE ) )
    {
        #if DEV
        printt( "[BurnCardDiceRoll] ", player, "Already has Urban Renewal Boost!" )
        #endif
        thread BurnCardOnBoostFailThread( player )
        return
    }
    GiveServerFlagLifeLong( player, SFLAG_HUNTER_SPECTRE )
}
// Most Wanted List
void function PlayerUsesMostWantedList( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Most Wanted List Boost!" )
    #endif
    if ( PlayerHasServerFlag( player, SFLAG_HUNTER_PILOT ) )
    {
        #if DEV
        printt( "[BurnCardDiceRoll] ", player, "Already has Most Wanted List Boost!" )
        #endif
        thread BurnCardOnBoostFailThread( player )
        return
    }
    GiveServerFlagLifeLong( player, SFLAG_HUNTER_PILOT )
}
// Outsource
void function PlayerUsesOutsource( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Outsource Boost!" )
    #endif
    if ( PlayerHasServerFlag( player, SFLAG_FAST_BUILD2 ) )
    {
        #if DEV
        printt( "[BurnCardDiceRoll] ", player, "Already has Outsource Boost!" )
        #endif
        thread BurnCardOnBoostFailThread( player )
        return
    }
    GiveServerFlagLifeLong( player, SFLAG_FAST_BUILD2 )
}
// ------------ TF1 Burn Cards - Weapons -------------
// Amped Smart Pistol - Replaces primary
void function PlayerUsesAmpedSmartPistol( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Amped Smart Pistol Boost!" )
    #endif
    // You can't drop Smart Pistol, but it can be in non-primary slot if it was given by script or cheat.
    foreach ( entity weapon in player.GetMainWeapons() )
    {
        if ( weapon.GetWeaponClassName() == "mp_weapon_smart_pistol" )
        {
            #if DEV
            printt( "[BurnCardDiceRoll] ", player, "Already has Amped Smart Pistol Boost!" )
            #endif
            thread BurnCardOnBoostFailThread( player )
            return
        }
    }
    entity primary = player.GetMainWeapons()[0]
    player.TakeWeaponNow( primary.GetWeaponClassName() )
    player.GiveWeapon( "mp_weapon_smart_pistol", [ "extended_ammo" ] ) // it'll still have limited ammo.
	player.SetActiveWeaponByName( "mp_weapon_smart_pistol" )
}
// TWIN-B Shotgun - Replaces primary
void function PlayerUsesDblBarrelShotgun( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got TWIN-B Shotgun Boost!" )
    #endif
    foreach ( entity weapon in player.GetMainWeapons() )
    {
        if ( weapon.GetWeaponClassName() == "mp_weapon_shotgun_doublebarrel" )
        {
            #if DEV
            printt( "[BurnCardDiceRoll] ", player, "Already has TWIN-B Shotgun!" )
            #endif
            thread BurnCardOnBoostFailThread( player )
            return
        }
    }
    entity primary = player.GetMainWeapons()[0]
    player.TakeWeaponNow( primary.GetWeaponClassName() )
    player.GiveWeapon( "mp_weapon_shotgun_doublebarrel" )
	player.SetActiveWeaponByName( "mp_weapon_shotgun_doublebarrel" )
}
// ------------ TF1 Burn Cards - Titan related -------------
// Turbo Engine
void function PlayerUsesTurboEngine( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Turbo Engine Boost!" )
    #endif
    // Can't be applied on Titan directly. Store it until player embarks titan.
    if ( !( "bc_titanboosts_player" in player.s ) )
    {
        #if DEV
        printt( "[BurnCardDiceRoll] ", player, "bc_titanboosts_player doesn't exist in entity struct, creating new one." )
        #endif
        player.s.bc_titanboosts_player <- []
    }
    // Apply this mod only once
    else
    {
        if ( player.s.bc_titanboosts_player.find( "bc_extra_dash" ) != -1 )
        {
            #if DEV
            printt( "[BurnCardDiceRoll] ", player, "Already has Turbo Engine Boost!" )
            #endif
            thread BurnCardOnBoostFailThread( player )
            return
        }
    }
    player.s.bc_titanboosts_player.append( "bc_extra_dash" )
}
// Super Charger
void function PlayerUsesSuperCharger( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Super Charger Boost!" )
    #endif
    // Since we're receiving this reward as pilot, check if we have titan.
    entity titan = player.GetPetTitan()
    if ( IsValid( titan ) )
    {
        // Apply this mod only once
        entity soul = titan.GetTitanSoul()
        if ( SoulTitanCore_GetNextAvailableTime( soul ) >= 1.0 )
        {
            #if DEV
            printt( "[BurnCardDiceRoll] ", titan, "Already has Core available!" )
            #endif
            thread BurnCardOnBoostFailThread( player )
            return
        }
        else
        {
            SoulTitanCore_SetNextAvailableTime( soul, 1.0 ) // 1.0 - 100%
            AddPlayerScore( player, "TitanCoreEarned", player )
        }
    }
    else
    {
        // Store it until titan call.
        StoreTitanBoost( player, "bc_core_charged" )
    }
}
// Massive Payload
void function PlayerUsesMassivePayload( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Massive Payload Boost!" )
    #endif
    // Since we're receiving this reward as pilot, check if we have titan.
    entity titan = player.GetPetTitan()
    if ( IsValid( titan ) )
    {
        // Apply this mod only once
        entity soul = titan.GetTitanSoul()
        if ( soul.passives[ ePassives.PAS_NUCLEAR_CORE ] == true )
        {
            #if DEV
            printt( "[BurnCardDiceRoll] ", titan, "Already has Massive Payload Boost!" )
            #endif
            thread BurnCardOnBoostFailThread( player )
            return
        }
        else
        {
            soul.passives[ ePassives.PAS_NUCLEAR_CORE ] = true
        }
    }
    else
    {
        // Store it until titan call.
        StoreTitanBoost( player, "bc_nuclear_core" )
    }
}
// Titan Salvage
void function PlayerUsesTitanSalvage( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Titan Salvage Boost!" )
    #endif
    // Apply this mod only once
    if ( PlayerHasPassive( player, ePassives.PAS_AT_HUNTER ) )
    {
        #if DEV
        printt( "[BurnCardDiceRoll] ", player, "Already has Titan Salvage Boost!" )
        #endif
        thread BurnCardOnBoostFailThread( player )
        return
    }
    GivePassiveLifeLong( player, ePassives.PAS_AT_HUNTER )
}
// Permanent Amped Titan weapons and abilities
void function PlayerUsesTitanAmpedWeapons( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Titan Amped Weapons Boost!" )
    #endif
    // Since we're receiving this reward as pilot, check if we have titan.
    entity titan = player.GetPetTitan()

    if ( IsValid( titan ) )
    {
        // Apply this mod only once
        entity soul = titan.GetTitanSoul()
        if ( "bc_titanboosts" in soul.s )
        {
            var index_boost = soul.s.bc_titanboosts.find( "bc_titan_amped_smoke" )
            if ( index_boost != -1 )
			{
                #if DEV
                printt( "[BurnCardDiceRoll] ", player, "Already has Titan Amped Weapons Boost!" )
                #endif
                thread BurnCardOnBoostFailThread( player )
                return
			}
        }
        #if DEV
        printt( "[BurnCardDiceRoll] ", soul, "Amping Titan weapons..." )
        #endif
        foreach ( entity weapon in titan.GetMainWeapons() )
        {
            #if DEV
            printt( "[BurnCardDiceRoll] ", titan, "Weapon: " + weapon )
            #endif
		    foreach ( string mod in GetWeaponBurnMods( weapon.GetWeaponClassName() ) )
            {
                #if DEV
                printt( "[BurnCardDiceRoll] ", titan, "Burn Mod: " + mod )
                #endif
			    weapon.AddMod( mod )
            }

            #if DEV
            printt( "[BurnCardDiceRoll] ", titan, "Weapon Mods: " )
            #endif

            foreach ( string mod in weapon.GetMods() )
                printt( mod )
        }
        array<int> offhandSlots = [ OFFHAND_MELEE, OFFHAND_LEFT, OFFHAND_RIGHT, OFFHAND_ANTIRODEO, OFFHAND_INVENTORY ]
        foreach ( slot in offhandSlots )
        {
            entity weapon = titan.GetOffhandWeapon( slot )
            if ( IsValid( weapon ) )
            {
                #if DEV
                printt( "[BurnCardDiceRoll] ", titan, "Weapon: " + weapon )
                #endif
                foreach ( string mod in GetWeaponBurnMods( weapon.GetWeaponClassName() ) )
                {
                    #if DEV
                    printt( "[BurnCardDiceRoll] ", titan, "Burn Mod: " + mod )
                    #endif
                    weapon.AddMod( mod )
                }
                if ( slot != OFFHAND_MELEE )
                {
                    // Rearm offhands
                    int maxammo = weapon.GetWeaponPrimaryClipCountMax()
                    weapon.SetWeaponPrimaryClipCount( maxammo )
                }
                #if DEV
                printt( "[BurnCardDiceRoll] ", titan, "Weapon Mods: " )
                #endif
                foreach ( string mod in weapon.GetMods() )
                printt( mod )
            }
        }
        // Store amped smoke boost until titan will get one
        StoreTitanBoost( soul, "bc_titan_amped_smoke" )
    }
    else
    {
        // Store it until titan call.
        StoreTitanBoost( player, "bc_titan_amped_weapons" )
    }
}
// ----------------- Custom - Pilot Abilities -----------------
// Super Pulse Blade
void function PlayerUsesSuperPulseBlade( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Super Pulse Blade Boost!" )
    #endif
    player.TakeOffhandWeapon( OFFHAND_SPECIAL )
    // Reusing existing mod index
    // While spree mods have arc indicators, they don't show ability cooldown time, because max ammo is too low.
    player.GiveOffhandWeapon( "mp_weapon_grenade_sonar", OFFHAND_SPECIAL, [ "bc_arc_refill" ] )
}
// Pulse Blade Jammer
void function PlayerUsesPulseBladeJammer( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Pulse Blade Jammer Boost!" )
    #endif
    player.TakeOffhandWeapon( OFFHAND_SPECIAL )
    // Reusing existing mod index
    player.GiveOffhandWeapon( "mp_weapon_grenade_sonar", OFFHAND_SPECIAL, [ "burn_mod_emp_grenade" ] )
}
// Holopilot Shift
void function PlayerUsesHolopilotShift( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Holopilot Shift Boost!" )
    #endif
    player.TakeOffhandWeapon( OFFHAND_SPECIAL )
    player.GiveOffhandWeapon( "mp_ability_holopilot", OFFHAND_SPECIAL, [ "bc_holoshift" ] )
}
// Holopilot Mimic
void function PlayerUsesHolopilotMimic( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Holopilot Mimic Boost!" )
    #endif
    player.TakeOffhandWeapon( OFFHAND_SPECIAL )
    player.GiveOffhandWeapon( "mp_ability_holopilot", OFFHAND_SPECIAL, [ "bc_holomimic" ] )
}
// Super Phase Shift
void function PlayerUsesSuperPhaseShift( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Super Phase Shift Boost!" )
    #endif
    player.TakeOffhandWeapon( OFFHAND_SPECIAL )
    // Reusing existing mod index
    player.GiveOffhandWeapon( "mp_ability_shifter", OFFHAND_SPECIAL, [ "long_last_shifter" ] )
}
// Explosive Phase Shift
void function PlayerUsesExplosivePhaseShift( entity player )
{
    #if DEV
    printt( player, "Got Explosive Phase Shift Boost!" )
    #endif
    player.TakeOffhandWeapon( OFFHAND_SPECIAL )
    player.GiveOffhandWeapon( "mp_ability_shifter", OFFHAND_SPECIAL, [ "pm2" ] )
}
// Long Grapple
void function PlayerUsesLongGrapple( entity player )
{
    #if DEV
    printt( player, "Got Long Grapple Boost!" )
    #endif
    player.TakeOffhandWeapon( OFFHAND_SPECIAL )
    // Reusing existing mod index
    player.GiveOffhandWeapon( "mp_ability_grapple", OFFHAND_SPECIAL, [ "spree_lvl1_grapple" ] )
}
// Grapple with 3 charges
void function PlayerUsesSuperGrapple( entity player )
{
    #if DEV
    printt( player, "Got Grapple with 3 charges Boost!" )
    #endif
    player.TakeOffhandWeapon( OFFHAND_SPECIAL )
    player.GiveOffhandWeapon( "mp_ability_grapple", OFFHAND_SPECIAL, [ "all_grapple" ] )
}
// Phase Lifesaver - Phase Rewind on critical damage
void function PlayerUsesPhaseLifesaverRewind( entity player )
{
    #if DEV
    printt( player, "Got Phase Rewind Lifesaver Boost!" )
    #endif
    // Apply this mod only once
    if ( !( "bc_lifesave_rewind" in player.s ) )
    {
        player.s.bc_lifesave_rewind <- false
    }
    else
    {
        if ( player.s.bc_lifesave_rewind == true )
        {
            #if DEV
            printt( "[BurnCardDiceRoll] ", player, "Already has Phase Rewind Lifesaver Boost!" )
            #endif
            thread BurnCardOnBoostFailThread( player )
            return
        }
    }
    player.s.bc_lifesave_rewind = true
}
// Phase Lifesaver - Phase Shift on critical damage
void function PlayerUsesPhaseLifesaverShift( entity player )
{
    #if DEV
    printt( player, "Got Phase Shift Lifesaver Boost!" )
    #endif
    // Apply this mod only once
    if ( !( "bc_lifesave_shift" in player.s ) )
    {
        player.s.bc_lifesave_shift <- false
    }
    else
    {
        if ( player.s.bc_lifesave_shift == true )
        {
            #if DEV
            printt( "[BurnCardDiceRoll] ", player, "Already has Phase Shift Lifesaver Boost!" )
            #endif
            thread BurnCardOnBoostFailThread( player )
            return
        }
    }
    player.s.bc_lifesave_shift = true
}
// Personal Shield
void function PlayerUsesPersonalShield( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Personal Shield Boost!" )
    #endif
    if ( GetEntArrayByScriptName( player.GetPlayerName() + "_cover" ).len() != 0 || GetEntArrayByScriptName( player.GetPlayerName() + "_ampedWall" ).len() != 0 )
    {
        #if DEV
        printt( "[BurnCardDiceRoll] ", player, "Already has Personal Shield Boost!" )
        #endif
        thread BurnCardOnBoostFailThread( player )
        return
    }
	else
        thread CreateMobileHardcover( player )
}
// vortex_sphere doesn't update pitch for whatever reason, let's re-use amped wall method.
void function CreateMobileHardcover( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "CreateMobileHardcover start!" )
    #endif
    EmitSoundOnEntity( player, "Hardcover_Shield_Start_3P" )
    vector angles = player.GetAngles()
    vector origin = player.GetOrigin()
    vector fwd = player.GetForwardVector()
    vector up = player.GetUpVector()
    
    origin = origin + (fwd * 16.0)
    origin = origin + (up * 5.0)

    entity mover = CreateScriptMover()
    mover.SetOrigin( player.GetOrigin() )
    vector moverAngles = player.GetAngles()
    mover.SetAngles( AnglesCompose( moverAngles, <0,0,180> ) )

    entity shieldLight = StartParticleEffectOnEntity_ReturnEntity( mover, file.shieldFxLight, FX_PATTACH_ABSORIGIN_FOLLOW, 0 )
    shieldLight.SetAngles( <0,0,180> )
    EffectSetControlPointVector( shieldLight, 1, <115.0, 247.0, 255.0> )
    shieldLight.DisableHibernation()

    angles = AnglesCompose( angles, <0,180,0> )
    entity hardCover = CreatePropDynamic( $"models/fx/pilot_shield_wall_amped.mdl", origin, angles, SOLID_VPHYSICS )
    hardCover.SetScriptName( player.GetPlayerName() + "_cover" )
    hardCover.SetOwner( player )
    hardCover.kv.contents = ( CONTENTS_WINDOW | CONTENTS_NOGRAPPLE )
    hardCover.kv.CollisionGroup = TRACE_COLLISION_GROUP_BLOCK_WEAPONS_AND_PHYSICS
    hardCover.SetBlocksRadiusDamage( true )
    hardCover.Hide()
    hardCover.DisableGrappleAttachment()
    hardCover.SetTakeDamageType( DAMAGE_YES )
    hardCover.SetDamageNotifications( true )
    hardCover.SetMaxHealth( DEPLOYABLE_SHIELD_HEALTH )
    hardCover.SetHealth( DEPLOYABLE_SHIELD_HEALTH )
    hardCover.s.lastDamagedTime <- 0.0
    hardCover.EndSignal( "OnDestroy" )
    // Particle shield doesn't want to update rotation after parenting, so I need to create all shield parts as props.
    entity hardCover_shell = CreatePropDynamic( $"models/fx/pilot_shield_wall.mdl", origin, angles )
    hardCover_shell.kv.rendermode = 1
    hardCover_shell.kv.rendercolor = "115 247 255 255"
    hardCover_shell.SetParent( hardCover )
    entity hardCover_part1 = CreatePropDynamic( $"models/fx/pilot_shield_wall_01.mdl", origin, angles )
    hardCover_part1.kv.rendermode = 1
    hardCover_part1.kv.rendercolor = "115 247 255 255"
    hardCover_part1.SetParent( hardCover )
    entity hardCover_part2 = CreatePropDynamic( $"models/fx/pilot_shield_wall_02.mdl", origin, angles )
    hardCover_part2.kv.rendermode = 1
    hardCover_part2.kv.rendercolor = "115 247 255 255"
    hardCover_part2.SetParent( hardCover )
    entity hardCover_part3 = CreatePropDynamic( $"models/fx/pilot_shield_wall_03.mdl", origin, angles )
    hardCover_part3.kv.rendermode = 1
    hardCover_part3.kv.rendercolor = "115 247 255 255"
    hardCover_part3.SetParent( hardCover )

    EndSignal( player, "OnDeath" )
    EndSignal( player, "OnDestroy" )

    SetVisibleEntitiesInConeQueriableEnabled( hardCover, true )
    AddEntityCallback_OnDamaged( hardCover, OnMobileHardCoverDamaged )

    hardCover.SetPassThroughThickness( 0 )
    hardCover.SetPassThroughDirection( -0.55 )
    CreateAirShakeRumbleOnly( origin, 16, 150, 0.6, 150 )
    hardCover.SetParent( mover )

    #if DEV
    printt( "[BurnCardDiceRoll] CreateMobileHardCover - Mover: ", mover, " Main model: ", hardCover )
    #endif

    OnThreadEnd(
        function() : ( hardCover, hardCover_shell, hardCover_part1, hardCover_part2, hardCover_part3, player, mover, shieldLight )
        {
            if ( IsValid( player ) )
            {
                StopSoundOnEntity( player, "Hardcover_Shield_Start_3P" )
                EmitSoundOnEntity( player, "Hardcover_Shield_End_3P" )
            }
            if ( IsValid( hardCover ) )
            {
                hardCover_shell.Destroy()
                hardCover_part1.Destroy()
                hardCover_part2.Destroy()
                hardCover_part3.Destroy()
                hardCover.Destroy()
            }  
            if ( IsValid( shieldLight ) )
                shieldLight.Destroy()

            if ( IsValid( mover ) )
				mover.Destroy()
        }
    )

    WaitFrame()
    thread TrackMobileHardCover( player, hardCover, shieldLight )

    for ( ;; )
	{
        Assert( IsAlive( player ) )
		UpdateMobileShieldPosition( mover, player )
    }
}
void function TrackMobileHardCover( entity player, entity hardCover, entity shieldLight )
{
    player.EndSignal( "OnDeath" )
    player.EndSignal( "OnDestroy" )
    hardCover.EndSignal( "OnDestroy" )

    if ( !IsAlive( player ) )
        return

    if ( !IsValid( hardCover ) )
        return

    float lastTime = Time()

    while( true )
    {               
        WaitFrame()

        // Regenerate shield if it hasn't been damaged recently.
        int coverHealth = hardCover.GetHealth()

        if ( coverHealth < DEPLOYABLE_SHIELD_HEALTH )
        {
            if ( Time() - hardCover.s.lastDamagedTime >= 5.0 )
            {
                float frameTime = max( 0.0, Time() - lastTime )
                #if DEV
                printt( "[BurnCardDiceRoll] ", hardCover, "Frame Time: ", frameTime )
                printt( "[BurnCardDiceRoll] ", hardCover, "Old Health: ", hardCover.GetHealth() )
                #endif
                // SHIELD_REGEN_TICK_TIME = 0.1
                hardCover.SetHealth( minint( DEPLOYABLE_SHIELD_HEALTH, int( coverHealth + 20 * frameTime / SHIELD_REGEN_TICK_TIME ) ) )
                #if DEV
                printt( "[BurnCardDiceRoll] ", hardCover, "New Health: ", hardCover.GetHealth() )
                #endif
            }
            // Update colors
            vector color = GetShieldTriLerpColor( 1 - GetHealthFrac( hardCover ) )
            EffectSetControlPointVector( shieldLight, 1, color )

            entity childEnt = hardCover.FirstMoveChild()
            entity nextChildEnt
            while ( childEnt != null )
            {
                if ( childEnt.GetClassName() == "prop_dynamic" )
                {
                    childEnt.kv.rendercolor = int(color.x).tostring()+ " " + int(color.y).tostring() + " " + int(color.z).tostring() + " 255"
                }
                nextChildEnt = childEnt.NextMovePeer()
                childEnt = nextChildEnt
            }
        }

        lastTime = Time()

        if ( player.IsTitan() )
        {
            DisableMobileShield( player, hardCover, null, shieldLight )
            continue
        }
        if ( player.ContextAction_IsActive() )
        {
            DisableMobileShield( player, hardCover, null, shieldLight )
            continue
        }
        if ( player.IsPhaseShifted() )
        {
            DisableMobileShield( player, hardCover, null, shieldLight )
            continue
        }
        if ( IsCloaked( player ) )
        {
            DisableMobileShield( player, hardCover, null, shieldLight )
            continue
        }
        if ( IsPlayerDisembarking( player ) )
        {
            DisableMobileShield( player, hardCover, null, shieldLight )
            continue
        }
        if ( IsPlayerEmbarking( player ) )
        {
            DisableMobileShield( player, hardCover, null, shieldLight )
            continue
        }
        EnableMobileShield( player, hardCover, null, shieldLight )
    }
}
void function OnMobileHardCoverDamaged( entity hardCover, var damageInfo )
{
    entity attacker = DamageInfo_GetAttacker( damageInfo )
    entity attackerWeapon = DamageInfo_GetWeapon( damageInfo )
    
    if ( !IsValid( attacker ) )
        return

    if ( IsValid( attackerWeapon ) )
    {
        if ( attackerWeapon.GetWeaponClassName() == "mp_ability_grapple" )
            return
    }      

    if ( attacker.IsPlayer() )
        attacker.NotifyDidDamage( hardCover, 0, DamageInfo_GetDamagePosition( damageInfo ), DamageInfo_GetCustomDamageType( damageInfo ), DamageInfo_GetDamage( damageInfo ), DamageInfo_GetDamageFlags( damageInfo ), DamageInfo_GetHitGroup( damageInfo ), DamageInfo_GetWeapon( damageInfo ), DamageInfo_GetDistFromAttackOrigin( damageInfo ) )

    float damage = DamageInfo_GetDamage( damageInfo )
    ShieldDamageModifier damageModifier = GetShieldDamageModifier( damageInfo )
    damage *= damageModifier.damageScale

    DamageInfo_SetDamage( damageInfo, damage )
    hardCover.s.lastDamagedTime = Time()
}
// Mobile A-Wall
void function PlayerUsesMobileAmpedWall( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Mobile Amped Wall Boost!" )
    #endif
    if ( GetEntArrayByScriptName( player.GetPlayerName() + "_cover" ).len() != 0 || GetEntArrayByScriptName( player.GetPlayerName() + "_ampedWall" ).len() != 0 )
    {
        #if DEV
        printt( "[BurnCardDiceRoll] ", player, "Already has Amped Wall Boost!" )
        #endif
        thread BurnCardOnBoostFailThread( player )
        return
    }
	else
        thread CreateMobileAmpedWall( player )
}
void function CreateMobileAmpedWall( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "CreateMobileAmpedWall start!" )
    #endif
    EmitSoundOnEntity( player, "Hardcover_Shield_Start_3P" )
    vector angles = player.GetAngles()
    vector origin = player.GetOrigin()
    vector fwd = player.GetForwardVector()
    vector up = player.GetUpVector()
    
    origin = origin + (fwd * 16.0)
    origin = origin + (up * 5.0)

    entity mover = CreateScriptMover()
    mover.SetOrigin( player.GetOrigin() )
    vector moverAngles = player.GetAngles()
    mover.SetAngles( AnglesCompose( moverAngles, <0,0,180> ) )

    entity shieldFX = StartParticleEffectOnEntity_ReturnEntity( mover, file.shieldFxArcs, FX_PATTACH_ABSORIGIN_FOLLOW, 0 )
    shieldFX.SetAngles( <0,0,180> )
    EffectSetControlPointVector( shieldFX, 1, <255.0, 128.0, 0.0> )
    shieldFX.DisableHibernation()

    entity shieldLight = StartParticleEffectOnEntity_ReturnEntity( mover, file.shieldFxLight, FX_PATTACH_ABSORIGIN_FOLLOW, 0 )
    shieldLight.SetAngles( <0,0,180> )
    EffectSetControlPointVector( shieldLight, 1, <255.0, 128.0, 0.0> )
    shieldLight.DisableHibernation()

    angles = AnglesCompose( angles, <0,180,0> )
    entity ampedWall = CreatePropDynamic( $"models/fx/pilot_shield_wall_amped.mdl", origin, angles, SOLID_VPHYSICS )
    ampedWall.SetScriptName( player.GetPlayerName() + "_ampedWall" )
    ampedWall.SetOwner( player )
    ampedWall.kv.contents = ( CONTENTS_WINDOW | CONTENTS_NOGRAPPLE )
    ampedWall.kv.CollisionGroup = TRACE_COLLISION_GROUP_BLOCK_WEAPONS_AND_PHYSICS
    ampedWall.SetPassThroughFlags( PTF_ADDS_MODS | PTF_NO_DMG_ON_PASS_THROUGH )
    ampedWall.SetBlocksRadiusDamage( true )
    ampedWall.Hide()
    ampedWall.DisableGrappleAttachment()
    ampedWall.SetTakeDamageType( DAMAGE_YES )
    ampedWall.SetDamageNotifications( true )
    ampedWall.SetMaxHealth( DEPLOYABLE_AMPED_SHIELD_HEALTH )
    ampedWall.SetHealth( DEPLOYABLE_AMPED_SHIELD_HEALTH )
    ampedWall.EndSignal( "OnDestroy" )
    // Particle shield doesn't want to update rotation after parenting, so I need to create all shield parts as props.
    entity ampedWall_shell = CreatePropDynamic( $"models/fx/pilot_shield_wall.mdl", origin, angles )
    ampedWall_shell.kv.rendermode = 1
    ampedWall_shell.kv.rendercolor = "255 128 0 255"
    ampedWall_shell.SetParent( ampedWall )
    entity ampedWall_part1 = CreatePropDynamic( $"models/fx/pilot_shield_wall_01.mdl", origin, angles )
    ampedWall_part1.kv.rendermode = 1
    ampedWall_part1.kv.rendercolor = "255 128 0 255"
    ampedWall_part1.SetParent( ampedWall )
    entity ampedWall_part2 = CreatePropDynamic( $"models/fx/pilot_shield_wall_02.mdl", origin, angles )
    ampedWall_part2.kv.rendermode = 1
    ampedWall_part2.kv.rendercolor = "255 128 0 255"
    ampedWall_part2.SetParent( ampedWall )
    entity ampedWall_part3 = CreatePropDynamic( $"models/fx/pilot_shield_wall_03.mdl", origin, angles )
    ampedWall_part3.kv.rendermode = 1
    ampedWall_part3.kv.rendercolor = "255 128 0 255"
    ampedWall_part3.SetParent( ampedWall )

    EndSignal( player, "OnDeath" )
    EndSignal( player, "OnDestroy" )

    SetVisibleEntitiesInConeQueriableEnabled( ampedWall, true )
    AddEntityCallback_OnDamaged( ampedWall, OnMobileAmpedWallDamaged )

    SetTeam( ampedWall, TEAM_BOTH )

    ampedWall.SetPassThroughThickness( 0 )
    ampedWall.SetPassThroughDirection( -0.55 )
    StatusEffect_AddEndless( ampedWall, eStatusEffect.pass_through_amps_weapon, 1.0 )

    CreateAirShakeRumbleOnly( origin, 16, 150, 0.6, 150 )
    ampedWall.SetParent( mover )

    #if DEV
    printt( "[BurnCardDiceRoll] CreateMobileAmpedWall - Mover: ", mover, " Main model: ", ampedWall )
    #endif

    OnThreadEnd(
        function() : ( ampedWall, ampedWall_shell, ampedWall_part1, ampedWall_part2, ampedWall_part3, player, mover, shieldFX, shieldLight )
        {
            if ( IsValid( player ) )
            {
                StopSoundOnEntity( player, "Hardcover_Shield_Start_3P" )
                EmitSoundOnEntity( player, "Hardcover_Shield_End_3P" )
            }

            if ( IsValid( ampedWall ) )
            {
                ampedWall_shell.Destroy()
                ampedWall_part1.Destroy()
                ampedWall_part2.Destroy()
                ampedWall_part3.Destroy()
                ampedWall.Destroy()
            }  

            if ( IsValid( shieldFX ) )
                shieldFX.Destroy()

            if ( IsValid( shieldLight ) )
                shieldLight.Destroy()

            if ( IsValid( mover ) )
				mover.Destroy()
        }
    )

    WaitFrame()
    thread TrackMobileShield( player, ampedWall, shieldFX, shieldLight )

    for ( ;; )
	{
        Assert( IsAlive( player ) )
		UpdateMobileShieldPosition( mover, player )
    }
}
void function TrackMobileShield( entity player, entity ampedWallProp, entity shieldFX, entity shieldLight )
{
    player.EndSignal( "OnDeath" )
    player.EndSignal( "OnDestroy" )
    ampedWallProp.EndSignal( "OnDestroy" )

    if ( !IsAlive( player ) )
        return

    if ( !IsValid( ampedWallProp ) )
        return

    while( true )
    {               
        WaitFrame()

        if ( player.IsTitan() )
        {
            DisableMobileShield( player, ampedWallProp, shieldFX, shieldLight )
            continue
        }
        if ( player.ContextAction_IsActive() )
        {
            DisableMobileShield( player, ampedWallProp, shieldFX, shieldLight )
            continue
        }
        if ( player.IsPhaseShifted() )
        {
            DisableMobileShield( player, ampedWallProp, shieldFX, shieldLight )
            continue
        }
        if ( IsCloaked( player ) )
        {
            DisableMobileShield( player, ampedWallProp, shieldFX, shieldLight )
            continue
        }
        if ( IsPlayerDisembarking( player ) )
        {
            DisableMobileShield( player, ampedWallProp, shieldFX, shieldLight )
            continue
        }
        if ( IsPlayerEmbarking( player ) )
        {
            DisableMobileShield( player, ampedWallProp, shieldFX, shieldLight )
            continue
        }
        EnableMobileShield( player, ampedWallProp, shieldFX, shieldLight )
    }
}
void function DisableMobileShield( entity player, entity ampedWallProp, entity shieldFX, entity shieldLight )
{
    var solid = ampedWallProp.kv.solid
    expect string( solid )

    if ( solid != "0" )
    {
        #if DEV
        printt( "[BurnCardDiceRoll] DisableMobileShield" )
        printt( "[BurnCardDiceRoll] ampedWallProp.kv.solid: ", ampedWallProp.kv.solid )
        #endif
        ampedWallProp.kv.solid = 0
        entity childEnt = ampedWallProp.FirstMoveChild()
        entity nextChildEnt

        while ( childEnt != null )
        {
            if ( childEnt.GetClassName() == "prop_dynamic" )
            {
                childEnt.Hide()
            }

            nextChildEnt = childEnt.NextMovePeer()
            childEnt = nextChildEnt
        }

        if ( IsValid( shieldFX ) )
            EntFireByHandle( shieldFX, "Stop", "", 0, null, null )

        if ( IsValid( shieldLight ) )
            EntFireByHandle( shieldLight, "Stop", "", 0, null, null )

        StopSoundOnEntity( player, "Hardcover_Shield_Start_3P" )
        EmitSoundOnEntity( player, "Hardcover_Shield_End_3P" )
        WaitFrame()
    }
}
void function EnableMobileShield( entity player, entity ampedWallProp, entity shieldFX, entity shieldLight )
{
    var solid = ampedWallProp.kv.solid
    expect string( solid )

    if ( solid == "6" )
        return
    
    #if DEV
    printt( "[BurnCardDiceRoll] EnableMobileShield" )
    printt( "[BurnCardDiceRoll] ampedWallProp.kv.solid: ", ampedWallProp.kv.solid )
    #endif
    ampedWallProp.kv.solid = SOLID_VPHYSICS
    entity childEnt = ampedWallProp.FirstMoveChild()
    entity nextChildEnt

    while ( childEnt != null )
    {
        if ( childEnt.GetClassName() == "prop_dynamic" )
            childEnt.Show()

        nextChildEnt = childEnt.NextMovePeer()
        childEnt = nextChildEnt
    }

    if ( IsValid( shieldFX ) )
        EntFireByHandle( shieldFX, "Start", "", 0, null, null )
    if ( IsValid( shieldLight ) )
        EntFireByHandle( shieldLight, "Start", "", 0, null, null )

    EmitSoundOnEntity( player, "Hardcover_Shield_Start_3P" )
    WaitFrame()
}
void function UpdateMobileShieldPosition( entity mover, entity owner )
{
    vector origin = owner.GetOrigin()
    vector velocity = owner.GetVelocity()
    float absVelocity = velocity.Length2D()
    //printt( "absVelocity:", absVelocity )
    float forwardInput = owner.GetInputAxisForward()
    //printt( "forwardInput:", forwardInput )
    vector fwd = owner.GetForwardVector()
    // assuming that max speed is ~600 ups
    if ( absVelocity > 200 )
    {
        float mult = ( absVelocity - 200 ) / 400
        float offset = DEPLOYABLE_SHIELD_RADIUS * mult
        
        if ( forwardInput >= 0 )
        {
            origin = origin + (fwd * offset)
        }
        else if ( forwardInput < 0 )
        {
            origin = origin - (fwd * offset)
        }
    }
    mover.NonPhysicsMoveTo( origin, 0.1, 0.0, 0.0 )
    vector angles = owner.EyeAngles()
	float yaw = angles.y
	yaw %= 360
    mover.NonPhysicsRotateTo( <angles.x,yaw,180>, 0.1, 0, 0 )
    WaitFrame()
}
void function OnMobileAmpedWallDamaged( entity ampedWall, var damageInfo )
{
    entity attacker = DamageInfo_GetAttacker( damageInfo )
    entity attackerWeapon = DamageInfo_GetWeapon( damageInfo )
    
    if ( !IsValid( attacker ) )
        return

    if ( IsValid( attackerWeapon ) )
    {
        if ( attackerWeapon.GetWeaponClassName() == "mp_ability_grapple" )
            return
    }      

    if ( attacker.IsPlayer() )
        attacker.NotifyDidDamage( ampedWall, 0, DamageInfo_GetDamagePosition( damageInfo ), DamageInfo_GetCustomDamageType( damageInfo ), DamageInfo_GetDamage( damageInfo ), DamageInfo_GetDamageFlags( damageInfo ), DamageInfo_GetHitGroup( damageInfo ), DamageInfo_GetWeapon( damageInfo ), DamageInfo_GetDistFromAttackOrigin( damageInfo ) )

    float damage = DamageInfo_GetDamage( damageInfo )
    ShieldDamageModifier damageModifier = GetShieldDamageModifier( damageInfo )
    damage *= damageModifier.damageScale

    DamageInfo_SetDamage( damageInfo, damage )
}
// ----------------- Custom - Boosted Weapons -----------------
// Amped Grenades
void function PlayerUsesAmpedGrenades( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Amped Grenades Boost!" )
    #endif
    // Server-side only mod doesn't apply ordnance beam to clients.
    // Just give both pas_ordinance_pack and burn_mod
    entity weapon = player.GetOffhandWeapon( OFFHAND_ORDNANCE )

    if ( weapon )
    {
        // Check if it's already boosted
        bool hasBurnMod = weapon.GetWeaponSettingBool( eWeaponVar.is_burn_mod )
        if ( hasBurnMod )
        {
            printt( "[BurnCardDiceRoll] ", player, ": Grenades are already amped!" )
            thread BurnCardOnBoostFailThread( player )
            return
        }
        // Don't apply burn mod on Ticks, it'll make it limited
        if ( weapon.GetWeaponClassName() != "mp_weapon_frag_drone" )
        {
            #if DEV
            printt( "[BurnCardDiceRoll] Ordnance Weapon: " + weapon )
            #endif
            foreach ( string mod in GetWeaponBurnMods( weapon.GetWeaponClassName() ) )
            {
                // catch incompatibilities just in case
                #if DEV
                printt( "[BurnCardDiceRoll] Burn Mod: " + mod )
                #endif
                try
                {
                    weapon.AddMod( mod )
                }
                catch( ex )
                {
                    #if DEV
                    printt( "[BurnCardDiceRoll] Exception called!" )
                    #endif
                }
            }
            weapon.AddMod( "pas_ordnance_pack" )
            weapon.SetScriptFlags0( weapon.GetScriptFlags0() | WEAPONFLAG_AMPED )
        }
    }
}
// Arc Trap
void function PlayerUsesArcTrap( entity player )
{
    #if DEV
    printt( player, "Got Arc Trap Boost!" )
    #endif
    // Apply this mod only once
    entity offhandWeapon = player.GetOffhandWeapon( OFFHAND_ORDNANCE )
    if ( offhandWeapon.GetWeaponClassName() == "mp_weapon_arc_trap" )
    {
        #if DEV
        printt( "[BurnCardDiceRoll] ", player, "Already has Arc Trap Boost!" )
        #endif
        thread BurnCardOnBoostFailThread( player )
        return
    }
    player.TakeOffhandWeapon( OFFHAND_ORDNANCE )
    player.GiveOffhandWeapon( "mp_weapon_arc_trap", OFFHAND_ORDNANCE, [ "bc_arc_trap" ] )
}
// ----------------- Custom - Titan ------------------
// Titan Shield Regeneration
void function PlayerUsesTitanShieldRegen( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Titan Shield Regen Booster!" )
    #endif
    // Since we're receiving this reward as pilot, check if we have titan.
    entity titan = player.GetPetTitan()
    if ( IsValid( titan ) )
    {
        // Apply this mod only once
        entity soul = titan.GetTitanSoul()

        if ( soul.passives[ ePassives.PAS_SHIELD_REGEN ] == true )
        {
            #if DEV
            printt( "[BurnCardDiceRoll] ", titan, "Already has Titan Shield Regen Booster!" )
            #endif
            thread BurnCardOnBoostFailThread( player )
            return
        }
        else
        {
            soul.passives[ ePassives.PAS_SHIELD_REGEN ] = true
        }
    }
    else
    {
        // Store it until titan call.
        StoreTitanBoost( player, "bc_titan_shield_regen" )
    }
}
// Emergency Titan
void function PlayerUsesEmergencyTitan( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Emergency Titan Boost!" )
    #endif
    if ( !IsAlive( player.GetPetTitan() ) )
    {
        if ( IsReplacementTitanAvailableForGameState() || !player.isSpawning )
        {
            TitanLoadoutDef titanloadout = GetTitanLoadoutForPlayer( player )
            // Give warpfall instead of bubble shield.
            titanloadout.passive3 = "pas_warpfall"
            thread CreateTitanForPlayerAndHotdrop( player, GetTitanReplacementPoint( player, false ), titanloadout )
        }
    }
    else
    {
        #if DEV
        printt( "[BurnCardDiceRoll] ", player, "already has Titan!" )
        #endif
        thread BurnCardOnBoostFailThread( player )
    }
}
// Emergency Titan - No Core
void function PlayerUsesEmergencyTitanNoCore( entity player )
{  
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Emergency Titan (No Core) Boost!" )
    #endif
    if ( !IsAlive( player.GetPetTitan() ) )
    {
        if ( IsReplacementTitanAvailableForGameState() || !player.isSpawning )
        {
            TitanLoadoutDef titanloadout = GetTitanLoadoutForPlayer( player )
            // No core
            titanloadout.coreAbility = ""
            // Give warpfall instead of bubble shield.
            #if DEV
            printt( "[BurnCardDiceRoll] passive3: ", titanloadout.passive3 )
            #endif
            titanloadout.passive3 = "pas_warpfall"
            thread CreateTitanForPlayerAndHotdrop( player, GetTitanReplacementPoint( player, false ), titanloadout )
            wait 2.75 // Warpfall takes 2.5 seconds.
            // 50% health
            entity petTitan

            if ( player.IsTitan() )
                petTitan = player
            else
                petTitan = player.GetPetTitan()
            
            petTitan.SetMaxHealth( petTitan.GetHealth()/2 )
            #if DEV
            printt( "[BurnCardDiceRoll] ", petTitan, "Health: ", petTitan.GetHealth(), "Max Health: ", petTitan.GetMaxHealth() )
            #endif
        }
    }
    else
    {
        #if DEV
        printt( "[BurnCardDiceRoll] ", player, "already has Titan!" )
        #endif
        thread BurnCardOnBoostFailThread( player )
    }
}
// Amped Rider
void function PlayerUsesTitanAmpedRider( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Titan Amped Rider Boost!" )
    #endif

    // Since we're receiving this reward as pilot, check if we have titan.
    entity titan = player.GetPetTitan()
    if ( IsValid( titan ) )
    {
        entity soul = titan.GetTitanSoul()

        if ( IsValid( soul ) )
        {
            // Apply this mod only once
            if ( !( "bc_amped_rider" in soul.s ) )
            {
                soul.s.bc_amped_rider <- false
            }
            else
            {
                if ( soul.s.bc_amped_rider == true )
                {
                    #if DEV
                    printt( "[BurnCardDiceRoll] ", player, "Already Titan Amped Rider Boost!" )
                    #endif
                    thread BurnCardOnBoostFailThread( player )
                    return
                }
            }

            soul.s.bc_amped_rider = true
        }
    }
    else
    {
        // Store it until player embarks one.
        StoreTitanBoost( player, "bc_titan_amped_rider" )
    }
}
// Test on NPCs
void function GiveTitanAmpedRider( entity titan )
{
    entity soul = titan.GetTitanSoul()
    soul.s.bc_amped_rider <- true
}
// Titan Arc Field
void function PlayerUsesTitanArcField( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Titan Arc Field Booster!" )
    #endif
    // Since we're receiving this reward as pilot, check if we have titan.
    entity titan = player.GetPetTitan()
    if ( IsValid( titan ) )
    {
        entity soul = titan.GetTitanSoul()
        
        if ( soul.GetTargetName() == "empTitanSoul" )
        {
            #if DEV
            printt( "[BurnCardDiceRoll] ", titan, "already has Arc Field!" )
            #endif
            thread BurnCardOnBoostFailThread( player )
        }
        else
        {
            // Apply targetname, but activate only if Titan is not doomed.
            SetTargetName( soul, "empTitanSoul" )
            CreateMinimapZoneOnEntity( titan, ARC_TITAN_EMP_FIELD_RADIUS )

            if ( !soul.IsDoomed() )
                thread EMPTitanThinkConstant( titan )
        }
    }
    else
    {
        // Store it until player embarks one.
        StoreTitanBoost( player, "bc_titan_arc_field" )
    }
}
void function CreateMinimapZoneOnEntity( entity titan, float radius )
{
    int playerTeam = titan.GetTeam()
    entity empRadius = CreatePropScript( $"models/dev/empty_model.mdl", titan.GetOrigin() )
    empRadius.Minimap_SetObjectScale( ARC_TITAN_EMP_FIELD_RADIUS / 16000.0 )
    empRadius.Minimap_SetAlignUpright( true )
    empRadius.Minimap_SetHeightTracking( true )
    empRadius.Minimap_SetZOrder( MINIMAP_Z_OBJECT )
    empRadius.Minimap_DisplayDefault( TEAM_MILITIA, null )
    empRadius.Minimap_DisplayDefault( TEAM_IMC, null )
    SetTeam( empRadius, playerTeam )
    empRadius.SetParent( titan )

    if ( playerTeam == TEAM_IMC )
        empRadius.Minimap_SetCustomState( eMinimapObject_prop_script.SPAWNZONE_IMC )
    else
        empRadius.Minimap_SetCustomState( eMinimapObject_prop_script.SPAWNZONE_MIL )
}
// ----------------- Custom - Support NPCs ------------------
// Reaperfall
void function PlayerUsesReaperfall( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Reaperfall Boost!" )
    #endif
    PlayerUsesReaperfallBurncard( player )
}
// Grunt Droppod
void function PlayerUsesGruntDroppod( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Grunt Squad Boost!" )
    #endif
    SpawnSupportDropPod( player, "npc_soldier" )
}
// Spectre Droppod
void function PlayerUsesSpectreDroppod( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Spectre Squad Boost!" )
    #endif
    SpawnSupportDropPod( player, "npc_spectre" )
}
// Stalker Droppod
void function PlayerUsesStalkerDroppod( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Stalker Squad Boost!" )
    #endif
    SpawnSupportDropPod( player, "npc_stalker" )
}
// Shared Droppod spawn function
void function SpawnSupportDropPod( entity player, string npcClassName )
{
    Point spawnpoint = GetTitanReplacementPoint( player, false )
    Remote_CallFunction_Replay( player, "ServerCallback_ReplacementTitanSpawnpoint", spawnpoint.origin.x, spawnpoint.origin.y, spawnpoint.origin.z, Time() + 5 ) //manually set time
    
    int playerTeam = player.GetTeam()
    entity pod = CreateDropPod( spawnpoint.origin, spawnpoint.angles )
    SetTeam( pod, playerTeam )
    InitFireteamDropPod( pod )

    string squadName = MakeSquadName( playerTeam, UniqueString( "PlayerSupport" ) )

    array<entity> guys
    for ( int i = 0; i < 4 ;i++ )
	{
		entity npc = CreateNPC( npcClassName, playerTeam, spawnpoint.origin, spawnpoint.angles )
        SetSpawnflags( npc, SF_NPC_START_EFFICIENT )
        SetSpawnOption_Alert( npc )
        SetSpawnOption_OwnerPlayer( npc, player )
		DispatchSpawn( npc )
        // follower stuff
        npc.SetBossPlayer( player )
        npc.ai.preventOwnerDamage = true

		npc.SetParent( pod, "ATTACH", true )
        SetSquad( npc, squadName )

        npc.SetFollowGoalTolerance( 512 )
	    npc.SetFollowGoalCombatTolerance( 1200 )
	    npc.SetFollowTargetMoveTolerance( 256 )
        npc.AssaultSetGoalRadius( 1600 ) // 1600 is minimum for npc_stalker, works fine for others
        npc.AssaultSetArrivalTolerance( 256 )

        npc.EnableNPCFlag( NPC_ALLOW_INVESTIGATE | NPC_USE_SHOOTING_COVER | NPC_ALLOW_HAND_SIGNALS | NPC_ALLOW_FLEE | NPC_IGNORE_FRIENDLY_SOUND | NPC_NEW_ENEMY_FROM_SOUND | NPC_TEAM_SPOTTED_ENEMY )
        NPCFollowsPlayer( npc, player )
        npc.MakeInvisible()
        entity weapon = npc.GetActiveWeapon()
		if ( IsValid( weapon ) )
			weapon.MakeInvisible()
		guys.append( npc )
	}

    waitthread LaunchAnimDropPod( pod, "pod_testpath", spawnpoint.origin, spawnpoint.angles )
    ArrayRemoveDead( guys )
    ActivateFireteamDropPod( pod, guys )

    #if DEV
    if ( !guys.len() )
		printt( "[BurnCardDiceRoll] Attempted to activate grunts from Drop Pod but the array is empty" )
    #endif

    foreach ( npc in guys )
	{
		npc.SetEfficientMode( false )
	}
}
// Cloak Drone
void function PlayerUsesCloakDrone( entity player )
{
    #if DEV
    printt( "[BurnCardDiceRoll] ", player, "Got Cloak Drone Boost!" )
    #endif
    array<entity> droneArray = GetNPCCloakedDrones()
    foreach ( cloakedDrone in droneArray )
	{
        if ( cloakedDrone.GetOwner() == player )
        {
            #if DEV
            printt( "[BurnCardDiceRoll] ", player, "already has Cloak Drone!" )
            #endif
            thread BurnCardOnBoostFailThread( player )
            return
        }
    }

    Point spawnpoint = GetTitanReplacementPoint( player, false )
    vector droneSpawnOrigin = Vector( spawnpoint.origin.x, spawnpoint.origin.y, spawnpoint.origin.z + 4096 )
    entity petDrone = SpawnCloakDrone( player.GetTeam(), droneSpawnOrigin, spawnpoint.angles, droneSpawnOrigin, player )
    CreateMinimapZoneOnEntity( petDrone, 400.0 )
}